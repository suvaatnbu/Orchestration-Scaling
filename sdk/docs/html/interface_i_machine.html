<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VirtualBox Main API: IMachine Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">VirtualBox Main API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="interface_i_machine-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IMachine Interface Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> interface represents a virtual machine, or guest, created in VirtualBox.  
 <a href="interface_i_machine.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for IMachine:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interface_i_machine.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af28da645b00a821547d9cb8e92f8b7b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af28da645b00a821547d9cb8e92f8b7b0">lockMachine</a> (in <a class="el" href="interface_i_session.html">ISession</a> session, in <a class="el" href="_virtual_box_8idl.html#a5893ac36dd21da7bcd19a505205ea180">LockType</a> lockType)</td></tr>
<tr class="memdesc:af28da645b00a821547d9cb8e92f8b7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the machine for the given session to enable the caller to make changes to the machine or start the VM or control VM execution.  <br /></td></tr>
<tr class="separator:af28da645b00a821547d9cb8e92f8b7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75e76da42ef908795d235d995262c6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa75e76da42ef908795d235d995262c6f">launchVMProcess</a> (in <a class="el" href="interface_i_session.html">ISession</a> session, in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in wstring[] environmentChanges, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:aa75e76da42ef908795d235d995262c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new process that will execute the virtual machine and obtains a shared lock on the machine for the calling session.  <br /></td></tr>
<tr class="separator:aa75e76da42ef908795d235d995262c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21be3d39450fb895a1547c87636d40a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af21be3d39450fb895a1547c87636d40a">setBootOrder</a> (in unsigned long position, in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a> device)</td></tr>
<tr class="memdesc:af21be3d39450fb895a1547c87636d40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the given device to the specified position in the boot order.  <br /></td></tr>
<tr class="separator:af21be3d39450fb895a1547c87636d40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e106050b4d54f39836230719ad07e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8e106050b4d54f39836230719ad07e14">getBootOrder</a> (in unsigned long position, [retval] out <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a> device)</td></tr>
<tr class="memdesc:a8e106050b4d54f39836230719ad07e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device type that occupies the specified position in the boot order.  <br /></td></tr>
<tr class="separator:a8e106050b4d54f39836230719ad07e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e51fafec7442a48a86a59edec5ec217"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">attachDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a> type, in <a class="el" href="interface_i_medium.html">IMedium</a> medium)</td></tr>
<tr class="memdesc:a8e51fafec7442a48a86a59edec5ec217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a device and optionally mounts a medium to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device.  <br /></td></tr>
<tr class="separator:a8e51fafec7442a48a86a59edec5ec217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f8c3614866c1fe78c30357d6e70146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ad4f8c3614866c1fe78c30357d6e70146">attachDeviceWithoutMedium</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a> type)</td></tr>
<tr class="memdesc:ad4f8c3614866c1fe78c30357d6e70146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a device and optionally mounts a medium to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device.  <br /></td></tr>
<tr class="separator:ad4f8c3614866c1fe78c30357d6e70146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a8e406027e901cc260488f8617fb22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a59a8e406027e901cc260488f8617fb22">detachDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device)</td></tr>
<tr class="memdesc:a59a8e406027e901cc260488f8617fb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the device attached to a device slot of the specified bus.  <br /></td></tr>
<tr class="separator:a59a8e406027e901cc260488f8617fb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e34af9e99e5884bf0b2eb297344c92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af0e34af9e99e5884bf0b2eb297344c92">passthroughDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean passthrough)</td></tr>
<tr class="memdesc:af0e34af9e99e5884bf0b2eb297344c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the passthrough mode of an existing DVD device.  <br /></td></tr>
<tr class="separator:af0e34af9e99e5884bf0b2eb297344c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2883fc2f65c753bdc1d0ba22cd773c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab2883fc2f65c753bdc1d0ba22cd773c8">temporaryEjectDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean temporaryEject)</td></tr>
<tr class="memdesc:ab2883fc2f65c753bdc1d0ba22cd773c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the behavior for guest-triggered medium eject.  <br /></td></tr>
<tr class="separator:ab2883fc2f65c753bdc1d0ba22cd773c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31ab8471f5076792487779533a26df0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa31ab8471f5076792487779533a26df0">nonRotationalDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean nonRotational)</td></tr>
<tr class="memdesc:aa31ab8471f5076792487779533a26df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a flag in the device information which indicates that the medium is not based on rotational technology, i.e.  <br /></td></tr>
<tr class="separator:aa31ab8471f5076792487779533a26df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02655252429d66d75188bcc56e41e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa02655252429d66d75188bcc56e41e7d">setAutoDiscardForDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean discard)</td></tr>
<tr class="memdesc:aa02655252429d66d75188bcc56e41e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a flag in the device information which indicates that the medium supports discarding unused blocks (called trimming for SATA or unmap for SCSI devices) .This may or may not be supported by a particular drive, and is silently ignored in the latter case.  <br /></td></tr>
<tr class="separator:aa02655252429d66d75188bcc56e41e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c00b608a08986ee8e50555e59ae4214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a9c00b608a08986ee8e50555e59ae4214">setHotPluggableForDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean hotPluggable)</td></tr>
<tr class="memdesc:a9c00b608a08986ee8e50555e59ae4214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a flag in the device information which indicates that the attached device is hot pluggable or not.  <br /></td></tr>
<tr class="separator:a9c00b608a08986ee8e50555e59ae4214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ed8a03befa534d4df3c5342bf7fcf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa8ed8a03befa534d4df3c5342bf7fcf8">setBandwidthGroupForDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in <a class="el" href="interface_i_bandwidth_group.html">IBandwidthGroup</a> bandwidthGroup)</td></tr>
<tr class="memdesc:aa8ed8a03befa534d4df3c5342bf7fcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bandwidth group of an existing storage device.  <br /></td></tr>
<tr class="separator:aa8ed8a03befa534d4df3c5342bf7fcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c2637db1f0f0fe4a687a4c2c245218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a94c2637db1f0f0fe4a687a4c2c245218">setNoBandwidthGroupForDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device)</td></tr>
<tr class="memdesc:a94c2637db1f0f0fe4a687a4c2c245218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets no bandwidth group for an existing storage device.  <br /></td></tr>
<tr class="separator:a94c2637db1f0f0fe4a687a4c2c245218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3da9c7f26b4c630f3989f98b58515a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a1f3da9c7f26b4c630f3989f98b58515a">unmountMedium</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean force)</td></tr>
<tr class="memdesc:a1f3da9c7f26b4c630f3989f98b58515a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts any currently mounted medium (<a class="el" href="interface_i_medium.html">IMedium</a><b></b>, identified by the given UUID <em>id</em>) to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device.  <br /></td></tr>
<tr class="separator:a1f3da9c7f26b4c630f3989f98b58515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c82306d3603e3bb40f6ab7467d4ff18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">mountMedium</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in <a class="el" href="interface_i_medium.html">IMedium</a> medium, in boolean force)</td></tr>
<tr class="memdesc:a1c82306d3603e3bb40f6ab7467d4ff18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a medium (<a class="el" href="interface_i_medium.html">IMedium</a><b></b>, identified by the given UUID <em>id</em>) to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device.  <br /></td></tr>
<tr class="separator:a1c82306d3603e3bb40f6ab7467d4ff18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb22d03a2c75b298ce1ec0ae1dc154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ac3fb22d03a2c75b298ce1ec0ae1dc154">getMedium</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, [retval] out <a class="el" href="interface_i_medium.html">IMedium</a> medium)</td></tr>
<tr class="memdesc:ac3fb22d03a2c75b298ce1ec0ae1dc154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the virtual medium attached to a device slot of the specified bus.  <br /></td></tr>
<tr class="separator:ac3fb22d03a2c75b298ce1ec0ae1dc154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645de5a36a9fd0380d5651ec61013c54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a645de5a36a9fd0380d5651ec61013c54">getMediumAttachmentsOfController</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, [retval] out <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a>[] <a class="el" href="interface_i_machine.html#aef972b7f8785c3a3f98a592a246ca4b4">mediumAttachments</a>)</td></tr>
<tr class="memdesc:a645de5a36a9fd0380d5651ec61013c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of medium attachments which are attached to the the controller with the given name.  <br /></td></tr>
<tr class="separator:a645de5a36a9fd0380d5651ec61013c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a32585929a391a118c82778138df3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa8a32585929a391a118c82778138df3a">getMediumAttachment</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, [retval] out <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a> attachment)</td></tr>
<tr class="memdesc:aa8a32585929a391a118c82778138df3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a medium attachment which corresponds to the controller with the given name, on the given port and device slot.  <br /></td></tr>
<tr class="separator:aa8a32585929a391a118c82778138df3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2640706ef6d61ac1d430199d162035ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2640706ef6d61ac1d430199d162035ae">attachHostPCIDevice</a> (in long hostAddress, in long desiredGuestAddress, in boolean tryToUnbind)</td></tr>
<tr class="memdesc:a2640706ef6d61ac1d430199d162035ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches host PCI device with the given (host) PCI address to the PCI bus of the virtual machine.  <br /></td></tr>
<tr class="separator:a2640706ef6d61ac1d430199d162035ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b94280b4763b7522c4003b095a463d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a6b94280b4763b7522c4003b095a463d2">detachHostPCIDevice</a> (in long hostAddress)</td></tr>
<tr class="memdesc:a6b94280b4763b7522c4003b095a463d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach host PCI device from the virtual machine.  <br /></td></tr>
<tr class="separator:a6b94280b4763b7522c4003b095a463d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a508ff696684f587ae4a7db17bace62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a0a508ff696684f587ae4a7db17bace62">getNetworkAdapter</a> (in unsigned long slot, [retval] out <a class="el" href="interface_i_network_adapter.html">INetworkAdapter</a> adapter)</td></tr>
<tr class="memdesc:a0a508ff696684f587ae4a7db17bace62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the network adapter associated with the given slot.  <br /></td></tr>
<tr class="separator:a0a508ff696684f587ae4a7db17bace62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc365a671090919d1d01cec078f4b170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#afc365a671090919d1d01cec078f4b170">addStorageController</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in <a class="el" href="_virtual_box_8idl.html#ab955ac5f95964be27366be7bbc8f3cf0">StorageBus</a> connectionType, [retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a> controller)</td></tr>
<tr class="memdesc:afc365a671090919d1d01cec078f4b170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new storage controller (SCSI, SAS or SATA controller) to the machine and returns it as an instance of <a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>.  <br /></td></tr>
<tr class="separator:afc365a671090919d1d01cec078f4b170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21595d46844b061ab54c4a79915b676"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab21595d46844b061ab54c4a79915b676">getStorageControllerByName</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, [retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a> storageController)</td></tr>
<tr class="memdesc:ab21595d46844b061ab54c4a79915b676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a storage controller with the given name.  <br /></td></tr>
<tr class="separator:ab21595d46844b061ab54c4a79915b676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3768c3b8830806154fa9c5284b1cdb52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a3768c3b8830806154fa9c5284b1cdb52">getStorageControllerByInstance</a> (in <a class="el" href="_virtual_box_8idl.html#ab955ac5f95964be27366be7bbc8f3cf0">StorageBus</a> connectionType, in unsigned long instance, [retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a> storageController)</td></tr>
<tr class="memdesc:a3768c3b8830806154fa9c5284b1cdb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a storage controller of a specific storage bus with the given instance number.  <br /></td></tr>
<tr class="separator:a3768c3b8830806154fa9c5284b1cdb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cb6937da2196d9bc13d9670c6f6eaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af6cb6937da2196d9bc13d9670c6f6eaf">removeStorageController</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>)</td></tr>
<tr class="memdesc:af6cb6937da2196d9bc13d9670c6f6eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a storage controller from the machine with all devices attached to it.  <br /></td></tr>
<tr class="separator:af6cb6937da2196d9bc13d9670c6f6eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4d1c7791274f8baaef6e341f029cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a5d4d1c7791274f8baaef6e341f029cd2">setStorageControllerBootable</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in boolean bootable)</td></tr>
<tr class="memdesc:a5d4d1c7791274f8baaef6e341f029cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bootable flag of the storage controller with the given name.  <br /></td></tr>
<tr class="separator:a5d4d1c7791274f8baaef6e341f029cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e995ab41fff5b44e5ac4ad343b68df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a33e995ab41fff5b44e5ac4ad343b68df">addUSBController</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in <a class="el" href="_virtual_box_8idl.html#aa23093dc281cfe164756f86b5ebf7b97">USBControllerType</a> type, [retval] out <a class="el" href="interface_i_u_s_b_controller.html">IUSBController</a> controller)</td></tr>
<tr class="memdesc:a33e995ab41fff5b44e5ac4ad343b68df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new USB controller to the machine and returns it as an instance of <a class="el" href="interface_i_u_s_b_controller.html">IUSBController</a><b></b>.  <br /></td></tr>
<tr class="separator:a33e995ab41fff5b44e5ac4ad343b68df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb74d7d9bd334c2d60db04dd4d5c6bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a1cb74d7d9bd334c2d60db04dd4d5c6bc">removeUSBController</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>)</td></tr>
<tr class="memdesc:a1cb74d7d9bd334c2d60db04dd4d5c6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a USB controller from the machine.  <br /></td></tr>
<tr class="separator:a1cb74d7d9bd334c2d60db04dd4d5c6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c46fa3925e49086137b951057a5b60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ae3c46fa3925e49086137b951057a5b60">getUSBControllerByName</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, [retval] out <a class="el" href="interface_i_u_s_b_controller.html">IUSBController</a> controller)</td></tr>
<tr class="memdesc:ae3c46fa3925e49086137b951057a5b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a USB controller with the given type.  <br /></td></tr>
<tr class="separator:ae3c46fa3925e49086137b951057a5b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4e5dc869b4972cfedeb13ac92b96f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aef4e5dc869b4972cfedeb13ac92b96f6">getUSBControllerCountByType</a> (in <a class="el" href="_virtual_box_8idl.html#aa23093dc281cfe164756f86b5ebf7b97">USBControllerType</a> type, [retval] out unsigned long controllers)</td></tr>
<tr class="memdesc:aef4e5dc869b4972cfedeb13ac92b96f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of USB controllers of the given type attached to the VM.  <br /></td></tr>
<tr class="separator:aef4e5dc869b4972cfedeb13ac92b96f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199fe95549cf07429f183302c59061c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a199fe95549cf07429f183302c59061c3">getSerialPort</a> (in unsigned long slot, [retval] out <a class="el" href="interface_i_serial_port.html">ISerialPort</a> port)</td></tr>
<tr class="memdesc:a199fe95549cf07429f183302c59061c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the serial port associated with the given slot.  <br /></td></tr>
<tr class="separator:a199fe95549cf07429f183302c59061c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafab6ae895f017b6fefc7cbdc753af02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aafab6ae895f017b6fefc7cbdc753af02">getParallelPort</a> (in unsigned long slot, [retval] out <a class="el" href="interface_i_parallel_port.html">IParallelPort</a> port)</td></tr>
<tr class="memdesc:aafab6ae895f017b6fefc7cbdc753af02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parallel port associated with the given slot.  <br /></td></tr>
<tr class="separator:aafab6ae895f017b6fefc7cbdc753af02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6bfbad64020e26408625a9229c04a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2a6bfbad64020e26408625a9229c04a2">getExtraDataKeys</a> ([retval] out wstring[] keys)</td></tr>
<tr class="memdesc:a2a6bfbad64020e26408625a9229c04a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array representing the machine-specific extra data keys which currently have values defined.  <br /></td></tr>
<tr class="separator:a2a6bfbad64020e26408625a9229c04a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e5e2346988bfc8fa2f73b3b34a2823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a83e5e2346988bfc8fa2f73b3b34a2823">getExtraData</a> (in wstring key, [retval] out wstring value)</td></tr>
<tr class="memdesc:a83e5e2346988bfc8fa2f73b3b34a2823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns associated machine-specific extra data.  <br /></td></tr>
<tr class="separator:a83e5e2346988bfc8fa2f73b3b34a2823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f89295518cbfcd582c9a63602f795a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a79f89295518cbfcd582c9a63602f795a">setExtraData</a> (in wstring key, in wstring value)</td></tr>
<tr class="memdesc:a79f89295518cbfcd582c9a63602f795a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets associated machine-specific extra data.  <br /></td></tr>
<tr class="separator:a79f89295518cbfcd582c9a63602f795a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579aa5eb632fd4a0f85e53ed927ec9b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a579aa5eb632fd4a0f85e53ed927ec9b2">setSettingsFilePath</a> (in wstring <a class="el" href="interface_i_machine.html#a7e7b7939c050afa7475e249e06961e75">settingsFilePath</a>, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:a579aa5eb632fd4a0f85e53ed927ec9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently, it is an error to change this property on any machine.  <br /></td></tr>
<tr class="separator:a579aa5eb632fd4a0f85e53ed927ec9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb47e1d878566569b26893cc12bd8e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a> ()</td></tr>
<tr class="memdesc:a2eb47e1d878566569b26893cc12bd8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves any changes to machine settings made since the session has been opened or a new machine has been created, or since the last call to <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> or <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>.  <br /></td></tr>
<tr class="separator:a2eb47e1d878566569b26893cc12bd8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341ac035501a0c168ad9571bbe86eb02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a> ()</td></tr>
<tr class="memdesc:a341ac035501a0c168ad9571bbe86eb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards any changes to the machine settings made since the session has been opened or since the last call to <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> or <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>.  <br /></td></tr>
<tr class="separator:a341ac035501a0c168ad9571bbe86eb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939a4b0bf949b0347c9e9d2acf320d1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a939a4b0bf949b0347c9e9d2acf320d1b">unregister</a> (in <a class="el" href="_virtual_box_8idl.html#a0381acf2db95fe7b709d78553346ea1c">CleanupMode</a> cleanupMode, [retval] out <a class="el" href="interface_i_medium.html">IMedium</a>[] media)</td></tr>
<tr class="memdesc:a939a4b0bf949b0347c9e9d2acf320d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a machine previously registered with <a class="el" href="interface_i_virtual_box.html#a7a67d2e6643990d72949c8d6c806ed35">IVirtualBox::registerMachine</a><b></b> and optionally do additional cleanup before the machine is unregistered.  <br /></td></tr>
<tr class="separator:a939a4b0bf949b0347c9e9d2acf320d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8645f1405cd6d834a3be005c8d533d68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8645f1405cd6d834a3be005c8d533d68">deleteConfig</a> (in <a class="el" href="interface_i_medium.html">IMedium</a>[] media, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:a8645f1405cd6d834a3be005c8d533d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the files associated with this machine from disk.  <br /></td></tr>
<tr class="separator:a8645f1405cd6d834a3be005c8d533d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a235b5dc96eda9bc10b80b139fbbd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a53a235b5dc96eda9bc10b80b139fbbd5">exportTo</a> (in <a class="el" href="interface_i_appliance.html">IAppliance</a> appliance, in wstring location, [retval] out <a class="el" href="interface_i_virtual_system_description.html">IVirtualSystemDescription</a> <a class="el" href="interface_i_machine.html#af19c3adad1315ceb9bdac881e545e602">description</a>)</td></tr>
<tr class="memdesc:a53a235b5dc96eda9bc10b80b139fbbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the machine to an OVF appliance.  <br /></td></tr>
<tr class="separator:a53a235b5dc96eda9bc10b80b139fbbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce8554c37a221ab8d493bacc0dafff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#abce8554c37a221ab8d493bacc0dafff4">findSnapshot</a> (in wstring nameOrId, [retval] out <a class="el" href="interface_i_snapshot.html">ISnapshot</a> snapshot)</td></tr>
<tr class="memdesc:abce8554c37a221ab8d493bacc0dafff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a snapshot of this machine with the given name or UUID.  <br /></td></tr>
<tr class="separator:abce8554c37a221ab8d493bacc0dafff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d8797225812968b96f0663a02bd4ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a56d8797225812968b96f0663a02bd4ff">createSharedFolder</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in wstring hostPath, in boolean writable, in boolean automount, in wstring autoMountPoint)</td></tr>
<tr class="memdesc:a56d8797225812968b96f0663a02bd4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new permanent shared folder by associating the given logical name with the given host path, adds it to the collection of shared folders and starts sharing it.  <br /></td></tr>
<tr class="separator:a56d8797225812968b96f0663a02bd4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e6a10490fde39a3e97e2ae1d1fa3ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a30e6a10490fde39a3e97e2ae1d1fa3ce">removeSharedFolder</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>)</td></tr>
<tr class="memdesc:a30e6a10490fde39a3e97e2ae1d1fa3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the permanent shared folder with the given name previously created by <a class="el" href="interface_i_machine.html#a56d8797225812968b96f0663a02bd4ff">createSharedFolder</a><b></b> from the collection of shared folders and stops sharing it.  <br /></td></tr>
<tr class="separator:a30e6a10490fde39a3e97e2ae1d1fa3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbda0c226bb18cd02f01e8492bbe3a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aebbda0c226bb18cd02f01e8492bbe3a1">canShowConsoleWindow</a> ([retval] out boolean canShow)</td></tr>
<tr class="memdesc:aebbda0c226bb18cd02f01e8492bbe3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the VM console process can activate the console window and bring it to foreground on the desktop of the host PC.  <br /></td></tr>
<tr class="separator:aebbda0c226bb18cd02f01e8492bbe3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada877c47a8efa8a62967f8cb0387bfbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ada877c47a8efa8a62967f8cb0387bfbc">showConsoleWindow</a> ([retval] out long long winId)</td></tr>
<tr class="memdesc:ada877c47a8efa8a62967f8cb0387bfbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates the console window and brings it to foreground on the desktop of the host PC.  <br /></td></tr>
<tr class="separator:ada877c47a8efa8a62967f8cb0387bfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2fffade4b897eb659cc4602694676d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a9f2fffade4b897eb659cc4602694676d">getGuestProperty</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, out wstring value, out long long timestamp, out wstring flags)</td></tr>
<tr class="memdesc:a9f2fffade4b897eb659cc4602694676d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the machine's guest property store.  <br /></td></tr>
<tr class="separator:a9f2fffade4b897eb659cc4602694676d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a328440fca57459efcbeadb76c548b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a36a328440fca57459efcbeadb76c548b">getGuestPropertyValue</a> (in wstring property, [retval] out wstring value)</td></tr>
<tr class="memdesc:a36a328440fca57459efcbeadb76c548b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a value from the machine's guest property store.  <br /></td></tr>
<tr class="separator:a36a328440fca57459efcbeadb76c548b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269df6613496c92f104269c15a68ad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a269df6613496c92f104269c15a68ad9a">getGuestPropertyTimestamp</a> (in wstring property, [retval] out long long value)</td></tr>
<tr class="memdesc:a269df6613496c92f104269c15a68ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a property timestamp from the machine's guest property store.  <br /></td></tr>
<tr class="separator:a269df6613496c92f104269c15a68ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526521a6479eeaf3067550417a7bb888"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a526521a6479eeaf3067550417a7bb888">setGuestProperty</a> (in wstring property, in wstring value, in wstring flags)</td></tr>
<tr class="memdesc:a526521a6479eeaf3067550417a7bb888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets, changes or deletes an entry in the machine's guest property store.  <br /></td></tr>
<tr class="separator:a526521a6479eeaf3067550417a7bb888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86db68f492c701d4fd323cf6aab633b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a86db68f492c701d4fd323cf6aab633b9">setGuestPropertyValue</a> (in wstring property, in wstring value)</td></tr>
<tr class="memdesc:a86db68f492c701d4fd323cf6aab633b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or changes a value in the machine's guest property store.  <br /></td></tr>
<tr class="separator:a86db68f492c701d4fd323cf6aab633b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5bc248ab2a58bdab899dd0ab0b6b10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2b5bc248ab2a58bdab899dd0ab0b6b10">deleteGuestProperty</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>)</td></tr>
<tr class="memdesc:a2b5bc248ab2a58bdab899dd0ab0b6b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an entry from the machine's guest property store.  <br /></td></tr>
<tr class="separator:a2b5bc248ab2a58bdab899dd0ab0b6b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c7ee7d951f5138e0e495fb2b1d572e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a28c7ee7d951f5138e0e495fb2b1d572e">enumerateGuestProperties</a> (in wstring patterns, out wstring[] names, out wstring[] values, out long long[] timestamps, out wstring[] flags)</td></tr>
<tr class="memdesc:a28c7ee7d951f5138e0e495fb2b1d572e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the guest properties matching a set of patterns along with their values, timestamps and flags.  <br /></td></tr>
<tr class="separator:a28c7ee7d951f5138e0e495fb2b1d572e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854f70590d1680516cfd2e3ff0e2d7b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a854f70590d1680516cfd2e3ff0e2d7b6">querySavedGuestScreenInfo</a> (in unsigned long screenId, out unsigned long originX, out unsigned long originY, out unsigned long width, out unsigned long height, out boolean enabled)</td></tr>
<tr class="memdesc:a854f70590d1680516cfd2e3ff0e2d7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the guest dimensions from the saved state.  <br /></td></tr>
<tr class="separator:a854f70590d1680516cfd2e3ff0e2d7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed902b9273e462a3479896cb7520b690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aed902b9273e462a3479896cb7520b690">readSavedThumbnailToArray</a> (in unsigned long screenId, in <a class="el" href="_virtual_box_8idl.html#a23d1a7c7cf0f6da45ca389904e644d55">BitmapFormat</a> bitmapFormat, out unsigned long width, out unsigned long height, [retval] out octet[] data)</td></tr>
<tr class="memdesc:aed902b9273e462a3479896cb7520b690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thumbnail is retrieved to an array of bytes in the requested format.  <br /></td></tr>
<tr class="separator:aed902b9273e462a3479896cb7520b690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d60329c6bd61543f307fe1771a1f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a16d60329c6bd61543f307fe1771a1f4c">querySavedScreenshotInfo</a> (in unsigned long screenId, out unsigned long width, out unsigned long height, [retval] out <a class="el" href="_virtual_box_8idl.html#a23d1a7c7cf0f6da45ca389904e644d55">BitmapFormat</a>[] bitmapFormats)</td></tr>
<tr class="memdesc:a16d60329c6bd61543f307fe1771a1f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns available formats and size of the screenshot from saved state.  <br /></td></tr>
<tr class="separator:a16d60329c6bd61543f307fe1771a1f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f1daa5237065f1e430a367ceb9f77c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a49f1daa5237065f1e430a367ceb9f77c">readSavedScreenshotToArray</a> (in unsigned long screenId, in <a class="el" href="_virtual_box_8idl.html#a23d1a7c7cf0f6da45ca389904e644d55">BitmapFormat</a> bitmapFormat, out unsigned long width, out unsigned long height, [retval] out octet[] data)</td></tr>
<tr class="memdesc:a49f1daa5237065f1e430a367ceb9f77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Screenshot in requested format is retrieved to an array of bytes.  <br /></td></tr>
<tr class="separator:a49f1daa5237065f1e430a367ceb9f77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa561e166e64b11450803d0d981f2f093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa561e166e64b11450803d0d981f2f093">hotPlugCPU</a> (in unsigned long cpu)</td></tr>
<tr class="memdesc:aa561e166e64b11450803d0d981f2f093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plugs a CPU into the machine.  <br /></td></tr>
<tr class="separator:aa561e166e64b11450803d0d981f2f093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7f63a54fa7ef3250a0ad05528350dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a4b7f63a54fa7ef3250a0ad05528350dd">hotUnplugCPU</a> (in unsigned long cpu)</td></tr>
<tr class="memdesc:a4b7f63a54fa7ef3250a0ad05528350dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a CPU from the machine.  <br /></td></tr>
<tr class="separator:a4b7f63a54fa7ef3250a0ad05528350dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f67f4ee8ce7b5c36d967ad4eb441fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa1f67f4ee8ce7b5c36d967ad4eb441fc">getCPUStatus</a> (in unsigned long cpu, [retval] out boolean attached)</td></tr>
<tr class="memdesc:aa1f67f4ee8ce7b5c36d967ad4eb441fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current status of the given CPU.  <br /></td></tr>
<tr class="separator:aa1f67f4ee8ce7b5c36d967ad4eb441fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4108883f0ee02b97b062122a6bed96e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a4108883f0ee02b97b062122a6bed96e0">getEffectiveParavirtProvider</a> ([retval] out <a class="el" href="_virtual_box_8idl.html#ad4d63f64a610fd190118618ceac0f6ee">ParavirtProvider</a> <a class="el" href="interface_i_machine.html#a97cc37de9ba8da175b44e7c03baa34bd">paravirtProvider</a>)</td></tr>
<tr class="memdesc:a4108883f0ee02b97b062122a6bed96e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the effective paravirtualization provider for this VM.  <br /></td></tr>
<tr class="separator:a4108883f0ee02b97b062122a6bed96e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4119197c357526503a23bd06b4b00357"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a4119197c357526503a23bd06b4b00357">queryLogFilename</a> (in unsigned long idx, [retval] out wstring filename)</td></tr>
<tr class="memdesc:a4119197c357526503a23bd06b4b00357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries for the VM log file name of an given index.  <br /></td></tr>
<tr class="separator:a4119197c357526503a23bd06b4b00357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788bf7b15a62311430bfa72f4902d914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a788bf7b15a62311430bfa72f4902d914">readLog</a> (in unsigned long idx, in long long offset, in long long size, [retval] out octet[] data)</td></tr>
<tr class="memdesc:a788bf7b15a62311430bfa72f4902d914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the VM log file.  <br /></td></tr>
<tr class="separator:a788bf7b15a62311430bfa72f4902d914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8109a3cdf154e552fcf47b6198d464f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8109a3cdf154e552fcf47b6198d464f0">cloneTo</a> (in <a class="el" href="interface_i_machine.html">IMachine</a> target, in <a class="el" href="_virtual_box_8idl.html#a16234ad9f11c851b50869d9718b664a2">CloneMode</a> mode, in <a class="el" href="_virtual_box_8idl.html#a15b096f772b66efdc6c998d70e575fc7">CloneOptions</a>[] options, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:a8109a3cdf154e552fcf47b6198d464f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of this machine, either as a full clone (which means creating independent copies of the hard disk media, save states and so on), or as a linked clone (which uses its own differencing media, sharing the parent media with the source machine).  <br /></td></tr>
<tr class="separator:a8109a3cdf154e552fcf47b6198d464f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa185a60ce7daba42f2fc716f7d09bac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa185a60ce7daba42f2fc716f7d09bac4">moveTo</a> (in wstring folder, in wstring type, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:aa185a60ce7daba42f2fc716f7d09bac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move machine on to new place/folder.  <br /></td></tr>
<tr class="separator:aa185a60ce7daba42f2fc716f7d09bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b13d68cea80df3bc65a4a77f8f3c6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a78b13d68cea80df3bc65a4a77f8f3c6b">saveState</a> ([retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:a78b13d68cea80df3bc65a4a77f8f3c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the current execution state of a running virtual machine and stops its execution.  <br /></td></tr>
<tr class="separator:a78b13d68cea80df3bc65a4a77f8f3c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77849574e824b7911f2069f8733946ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a77849574e824b7911f2069f8733946ab">adoptSavedState</a> (in wstring savedStateFile)</td></tr>
<tr class="memdesc:a77849574e824b7911f2069f8733946ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given saved state file to the virtual machine.  <br /></td></tr>
<tr class="separator:a77849574e824b7911f2069f8733946ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be3ff72c6dbe36c86d5a4fa5774bd12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a6be3ff72c6dbe36c86d5a4fa5774bd12">discardSavedState</a> (in boolean fRemoveFile)</td></tr>
<tr class="memdesc:a6be3ff72c6dbe36c86d5a4fa5774bd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcibly resets the machine to "Powered Off" state if it is currently in the "Saved" state previously created by <a class="el" href="interface_i_machine.html#a78b13d68cea80df3bc65a4a77f8f3c6b">saveState</a><b></b>) or in the "AbortedSaved" state.  <br /></td></tr>
<tr class="separator:a6be3ff72c6dbe36c86d5a4fa5774bd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39f2d35139941c3c2eb1afcc1b5a319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab39f2d35139941c3c2eb1afcc1b5a319">takeSnapshot</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in wstring <a class="el" href="interface_i_machine.html#af19c3adad1315ceb9bdac881e545e602">description</a>, in boolean pause, out wstringUUID <a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a>, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:ab39f2d35139941c3c2eb1afcc1b5a319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the current execution state and all settings of the machine and creates differencing images for all normal (non-independent) media.  <br /></td></tr>
<tr class="separator:ab39f2d35139941c3c2eb1afcc1b5a319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d541f845c2744f78315d146cb86084c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a4d541f845c2744f78315d146cb86084c">deleteSnapshot</a> (in wstringUUID <a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a>, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:a4d541f845c2744f78315d146cb86084c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts deleting the specified snapshot asynchronously.  <br /></td></tr>
<tr class="separator:a4d541f845c2744f78315d146cb86084c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d9aa9722f4edc65eba6344a3c06061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab8d9aa9722f4edc65eba6344a3c06061">deleteSnapshotAndAllChildren</a> (in wstringUUID <a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a>, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:ab8d9aa9722f4edc65eba6344a3c06061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts deleting the specified snapshot and all its children asynchronously.  <br /></td></tr>
<tr class="separator:ab8d9aa9722f4edc65eba6344a3c06061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163ef21621c97c9b5acd8873e958732f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a163ef21621c97c9b5acd8873e958732f">deleteSnapshotRange</a> (in wstringUUID startId, in wstringUUID endId, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:a163ef21621c97c9b5acd8873e958732f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts deleting the specified snapshot range.  <br /></td></tr>
<tr class="separator:a163ef21621c97c9b5acd8873e958732f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b696740ceccb14750718e2648d6928c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a5b696740ceccb14750718e2648d6928c">restoreSnapshot</a> (in <a class="el" href="interface_i_snapshot.html">ISnapshot</a> snapshot, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:a5b696740ceccb14750718e2648d6928c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts resetting the machine's current state to the state contained in the given snapshot, asynchronously.  <br /></td></tr>
<tr class="separator:a5b696740ceccb14750718e2648d6928c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8708b1fd0f88ad7243a8a68bc5f44fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8708b1fd0f88ad7243a8a68bc5f44fe6">applyDefaults</a> (in wstring flags)</td></tr>
<tr class="memdesc:a8708b1fd0f88ad7243a8a68bc5f44fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the defaults for the configured guest OS type.  <br /></td></tr>
<tr class="separator:a8708b1fd0f88ad7243a8a68bc5f44fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4287a2fe395fee9ec6ab344868dc8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#afe4287a2fe395fee9ec6ab344868dc8b">changeEncryption</a> (in wstring currentPassword, in wstring cipher, in wstring newPassword, in wstring newPasswordId, in boolean force, [retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr class="memdesc:afe4287a2fe395fee9ec6ab344868dc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts encryption of this VM.  <br /></td></tr>
<tr class="separator:afe4287a2fe395fee9ec6ab344868dc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a50259750dc8d030ce9465795d75e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a86a50259750dc8d030ce9465795d75e9">getEncryptionSettings</a> (out wstring cipher, out wstring passwordId)</td></tr>
<tr class="memdesc:a86a50259750dc8d030ce9465795d75e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the encryption settings for this VM.  <br /></td></tr>
<tr class="separator:a86a50259750dc8d030ce9465795d75e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aad7a28412c13046bc78a14a4d522be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8aad7a28412c13046bc78a14a4d522be">checkEncryptionPassword</a> (in wstring password)</td></tr>
<tr class="memdesc:a8aad7a28412c13046bc78a14a4d522be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the supplied password is correct for the VM.  <br /></td></tr>
<tr class="separator:a8aad7a28412c13046bc78a14a4d522be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2987389c2cb0041edd49ae80d5b5e3ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2987389c2cb0041edd49ae80d5b5e3ff">addEncryptionPassword</a> (in wstring <a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a>, in wstring password)</td></tr>
<tr class="memdesc:a2987389c2cb0041edd49ae80d5b5e3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a password used for encryption.  <br /></td></tr>
<tr class="separator:a2987389c2cb0041edd49ae80d5b5e3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6851d6656d1dae72611051a223f1fd76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a6851d6656d1dae72611051a223f1fd76">addEncryptionPasswords</a> (in wstring[] ids, in wstring[] passwords)</td></tr>
<tr class="memdesc:a6851d6656d1dae72611051a223f1fd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds passwords used for encryption.  <br /></td></tr>
<tr class="separator:a6851d6656d1dae72611051a223f1fd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c71a0cf25fb4a0c881d0811a1bc74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a6e3c71a0cf25fb4a0c881d0811a1bc74">removeEncryptionPassword</a> (in wstring <a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a>)</td></tr>
<tr class="memdesc:a6e3c71a0cf25fb4a0c881d0811a1bc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a password used for the VM encryption/decryption.  <br /></td></tr>
<tr class="separator:a6e3c71a0cf25fb4a0c881d0811a1bc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36522d66247ff7eee6131d43d11367f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ad36522d66247ff7eee6131d43d11367f">clearAllEncryptionPasswords</a> ()</td></tr>
<tr class="memdesc:ad36522d66247ff7eee6131d43d11367f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all provided VM passwords.  <br /></td></tr>
<tr class="separator:ad36522d66247ff7eee6131d43d11367f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a06bb12649ae1d59be7dcf982d7a55817"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_virtual_box.html">IVirtualBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a06bb12649ae1d59be7dcf982d7a55817">parent</a></td></tr>
<tr class="memdesc:a06bb12649ae1d59be7dcf982d7a55817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associated parent object.  <br /></td></tr>
<tr class="separator:a06bb12649ae1d59be7dcf982d7a55817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffa156e95de8db401aea3f1f95b2e0c"><td class="memItemLeft" align="right" valign="top">attribute octet[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aaffa156e95de8db401aea3f1f95b2e0c">icon</a></td></tr>
<tr class="memdesc:aaffa156e95de8db401aea3f1f95b2e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overridden VM Icon details.  <br /></td></tr>
<tr class="separator:aaffa156e95de8db401aea3f1f95b2e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6c9cc91c11db18c5b6b870556355f2"><td class="memItemLeft" align="right" valign="top">readonly attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2b6c9cc91c11db18c5b6b870556355f2">accessible</a></td></tr>
<tr class="memdesc:a2b6c9cc91c11db18c5b6b870556355f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this virtual machine is currently accessible or not.  <br /></td></tr>
<tr class="separator:a2b6c9cc91c11db18c5b6b870556355f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cdf161d5d9f8e3e1491802768e533a"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_virtual_box_error_info.html">IVirtualBoxErrorInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a81cdf161d5d9f8e3e1491802768e533a">accessError</a></td></tr>
<tr class="memdesc:a81cdf161d5d9f8e3e1491802768e533a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error information describing the reason of machine inaccessibility.  <br /></td></tr>
<tr class="separator:a81cdf161d5d9f8e3e1491802768e533a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8041e0562be7a0b32be686384285f5"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a></td></tr>
<tr class="memdesc:a0f8041e0562be7a0b32be686384285f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the virtual machine.  <br /></td></tr>
<tr class="separator:a0f8041e0562be7a0b32be686384285f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19c3adad1315ceb9bdac881e545e602"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af19c3adad1315ceb9bdac881e545e602">description</a></td></tr>
<tr class="memdesc:af19c3adad1315ceb9bdac881e545e602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of the virtual machine.  <br /></td></tr>
<tr class="separator:af19c3adad1315ceb9bdac881e545e602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2872f28654d4cee4e8029bf6eaec60"><td class="memItemLeft" align="right" valign="top">readonly attribute wstringUUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a></td></tr>
<tr class="memdesc:a8c2872f28654d4cee4e8029bf6eaec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">UUID of the virtual machine.  <br /></td></tr>
<tr class="separator:a8c2872f28654d4cee4e8029bf6eaec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27536e99a6b64ac628a9098037ab5d7c"><td class="memItemLeft" align="right" valign="top">attribute wstring[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a27536e99a6b64ac628a9098037ab5d7c">groups</a></td></tr>
<tr class="memdesc:a27536e99a6b64ac628a9098037ab5d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of machine group names of which this machine is a member.  <br /></td></tr>
<tr class="separator:a27536e99a6b64ac628a9098037ab5d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b78acadfe037c9153080fb055f46a7d"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8b78acadfe037c9153080fb055f46a7d">OSTypeId</a></td></tr>
<tr class="memdesc:a8b78acadfe037c9153080fb055f46a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined identifier of the Guest OS type.  <br /></td></tr>
<tr class="separator:a8b78acadfe037c9153080fb055f46a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e9ec512ab94e9878a1f848c51c8832"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a40e9ec512ab94e9878a1f848c51c8832">hardwareVersion</a></td></tr>
<tr class="memdesc:a40e9ec512ab94e9878a1f848c51c8832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware version identifier.  <br /></td></tr>
<tr class="separator:a40e9ec512ab94e9878a1f848c51c8832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2573dd9ec7e316b4c3115e84db9cf83"><td class="memItemLeft" align="right" valign="top">attribute wstringUUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab2573dd9ec7e316b4c3115e84db9cf83">hardwareUUID</a></td></tr>
<tr class="memdesc:ab2573dd9ec7e316b4c3115e84db9cf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UUID presented to the guest via memory tables, hardware and guest properties.  <br /></td></tr>
<tr class="separator:ab2573dd9ec7e316b4c3115e84db9cf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fd87584b8d5e02ccdf061c12e8e299"><td class="memItemLeft" align="right" valign="top">attribute unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a78fd87584b8d5e02ccdf061c12e8e299">CPUCount</a></td></tr>
<tr class="memdesc:a78fd87584b8d5e02ccdf061c12e8e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of virtual CPUs in the VM.  <br /></td></tr>
<tr class="separator:a78fd87584b8d5e02ccdf061c12e8e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466c25d9049510f39c71f7bd75bad63b"><td class="memItemLeft" align="right" valign="top">attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a466c25d9049510f39c71f7bd75bad63b">CPUHotPlugEnabled</a></td></tr>
<tr class="memdesc:a466c25d9049510f39c71f7bd75bad63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This setting determines whether VirtualBox allows CPU hotplugging for this machine.  <br /></td></tr>
<tr class="separator:a466c25d9049510f39c71f7bd75bad63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47753f3eaff825b684018a2f88be95f6"><td class="memItemLeft" align="right" valign="top">attribute unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a47753f3eaff825b684018a2f88be95f6">CPUExecutionCap</a></td></tr>
<tr class="memdesc:a47753f3eaff825b684018a2f88be95f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Means to limit the number of CPU cycles a guest can use.  <br /></td></tr>
<tr class="separator:a47753f3eaff825b684018a2f88be95f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404c453a9d1d07b183798f1b1835b95a"><td class="memItemLeft" align="right" valign="top">attribute unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a404c453a9d1d07b183798f1b1835b95a">CPUIDPortabilityLevel</a></td></tr>
<tr class="memdesc:a404c453a9d1d07b183798f1b1835b95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual CPUID portability level.  <br /></td></tr>
<tr class="separator:a404c453a9d1d07b183798f1b1835b95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb5f057419fdc8505882ed5be4d6876"><td class="memItemLeft" align="right" valign="top">attribute unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a5bb5f057419fdc8505882ed5be4d6876">memorySize</a></td></tr>
<tr class="memdesc:a5bb5f057419fdc8505882ed5be4d6876"><td class="mdescLeft">&#160;</td><td class="mdescRight">System memory size in megabytes.  <br /></td></tr>
<tr class="separator:a5bb5f057419fdc8505882ed5be4d6876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8340bf65bbf1a384b7902cfe65a6dd5"><td class="memItemLeft" align="right" valign="top">attribute unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af8340bf65bbf1a384b7902cfe65a6dd5">memoryBalloonSize</a></td></tr>
<tr class="memdesc:af8340bf65bbf1a384b7902cfe65a6dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory balloon size in megabytes.  <br /></td></tr>
<tr class="separator:af8340bf65bbf1a384b7902cfe65a6dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c0171d96c683d579974f4a508a7cf0"><td class="memItemLeft" align="right" valign="top">attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a29c0171d96c683d579974f4a508a7cf0">pageFusionEnabled</a></td></tr>
<tr class="memdesc:a29c0171d96c683d579974f4a508a7cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This setting determines whether VirtualBox allows page fusion for this machine (64-bit hosts only).  <br /></td></tr>
<tr class="separator:a29c0171d96c683d579974f4a508a7cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabba6fd260612821bb75b86b12292f0c"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_graphics_adapter.html">IGraphicsAdapter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aabba6fd260612821bb75b86b12292f0c">graphicsAdapter</a></td></tr>
<tr class="memdesc:aabba6fd260612821bb75b86b12292f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Graphics adapter object.  <br /></td></tr>
<tr class="separator:aabba6fd260612821bb75b86b12292f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774e1dc666b5f28a0ba43c1ed0a8bdbf"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_platform.html">IPlatform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a774e1dc666b5f28a0ba43c1ed0a8bdbf">platform</a></td></tr>
<tr class="memdesc:a774e1dc666b5f28a0ba43c1ed0a8bdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associated platform object.  <br /></td></tr>
<tr class="separator:a774e1dc666b5f28a0ba43c1ed0a8bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6885010714dd25ffbf00b79c0144c9"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_firmware_settings.html">IFirmwareSettings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aca6885010714dd25ffbf00b79c0144c9">firmwareSettings</a></td></tr>
<tr class="memdesc:aca6885010714dd25ffbf00b79c0144c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object containing all firmware settings.  <br /></td></tr>
<tr class="separator:aca6885010714dd25ffbf00b79c0144c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235de4969e89db6d7d84c6f8d6bd4353"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_trusted_platform_module.html">ITrustedPlatformModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a235de4969e89db6d7d84c6f8d6bd4353">trustedPlatformModule</a></td></tr>
<tr class="memdesc:a235de4969e89db6d7d84c6f8d6bd4353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object containing all TPM settings.  <br /></td></tr>
<tr class="separator:a235de4969e89db6d7d84c6f8d6bd4353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af804d99f06ba056a08152eec3f686978"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_nvram_store.html">INvramStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af804d99f06ba056a08152eec3f686978">nonVolatileStore</a></td></tr>
<tr class="memdesc:af804d99f06ba056a08152eec3f686978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object to manipulate data in the non volatile storage file.  <br /></td></tr>
<tr class="separator:af804d99f06ba056a08152eec3f686978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724d49f862f89708a37d0bdcc6d49be1"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_recording_settings.html">IRecordingSettings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a724d49f862f89708a37d0bdcc6d49be1">recordingSettings</a></td></tr>
<tr class="memdesc:a724d49f862f89708a37d0bdcc6d49be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object containing all recording settings.  <br /></td></tr>
<tr class="separator:a724d49f862f89708a37d0bdcc6d49be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169cccf5417aa6c90b4515f45b919d2e"><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#ae904ea9e2892b3cb117b076fdf4c8897">PointingHIDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a169cccf5417aa6c90b4515f45b919d2e">pointingHIDType</a></td></tr>
<tr class="memdesc:a169cccf5417aa6c90b4515f45b919d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointing HID (such as mouse or tablet) used in this VM.  <br /></td></tr>
<tr class="separator:a169cccf5417aa6c90b4515f45b919d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837c6f223122e587ff00027346a9f148"><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#af8b91ad2ad35847326c7d9d4c9587142">KeyboardHIDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a837c6f223122e587ff00027346a9f148">keyboardHIDType</a></td></tr>
<tr class="memdesc:a837c6f223122e587ff00027346a9f148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of keyboard HID used in this VM.  <br /></td></tr>
<tr class="separator:a837c6f223122e587ff00027346a9f148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcf2b4359a54f318fa9f17ee521fd50"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#adfcf2b4359a54f318fa9f17ee521fd50">snapshotFolder</a></td></tr>
<tr class="memdesc:adfcf2b4359a54f318fa9f17ee521fd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full path to the directory used to store snapshot data (differencing media and saved state files) of this machine.  <br /></td></tr>
<tr class="separator:adfcf2b4359a54f318fa9f17ee521fd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fe661f18e88069711241ca227c1708"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_v_r_d_e_server.html">IVRDEServer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a74fe661f18e88069711241ca227c1708">VRDEServer</a></td></tr>
<tr class="memdesc:a74fe661f18e88069711241ca227c1708"><td class="mdescLeft">&#160;</td><td class="mdescRight">VirtualBox Remote Desktop Extension (VRDE) server object.  <br /></td></tr>
<tr class="separator:a74fe661f18e88069711241ca227c1708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31970f365eecc56cbf754eb0b1cf51a5"><td class="memItemLeft" align="right" valign="top">attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a31970f365eecc56cbf754eb0b1cf51a5">emulatedUSBCardReaderEnabled</a></td></tr>
<tr class="separator:a31970f365eecc56cbf754eb0b1cf51a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef972b7f8785c3a3f98a592a246ca4b4"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a>[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aef972b7f8785c3a3f98a592a246ca4b4">mediumAttachments</a></td></tr>
<tr class="memdesc:aef972b7f8785c3a3f98a592a246ca4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of media attached to this machine.  <br /></td></tr>
<tr class="separator:aef972b7f8785c3a3f98a592a246ca4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2be494c024c890a7c5cd44b33a793c7"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_u_s_b_controller.html">IUSBController</a>[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab2be494c024c890a7c5cd44b33a793c7">USBControllers</a></td></tr>
<tr class="memdesc:ab2be494c024c890a7c5cd44b33a793c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of USB controllers attached to this machine.  <br /></td></tr>
<tr class="separator:ab2be494c024c890a7c5cd44b33a793c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add060f5c12759baa796731f92e00655d"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_u_s_b_device_filters.html">IUSBDeviceFilters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#add060f5c12759baa796731f92e00655d">USBDeviceFilters</a></td></tr>
<tr class="memdesc:add060f5c12759baa796731f92e00655d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associated USB device filters object.  <br /></td></tr>
<tr class="separator:add060f5c12759baa796731f92e00655d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc58dbaf07bbb3eef30dc557de8ec00b"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_audio_settings.html">IAudioSettings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#adc58dbaf07bbb3eef30dc557de8ec00b">audioSettings</a></td></tr>
<tr class="memdesc:adc58dbaf07bbb3eef30dc557de8ec00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The machine's audio settings.  <br /></td></tr>
<tr class="separator:adc58dbaf07bbb3eef30dc557de8ec00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5638e205ed8f8a1473d3b866e9a7d4f"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_storage_controller.html">IStorageController</a>[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ac5638e205ed8f8a1473d3b866e9a7d4f">storageControllers</a></td></tr>
<tr class="memdesc:ac5638e205ed8f8a1473d3b866e9a7d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of storage controllers attached to this machine.  <br /></td></tr>
<tr class="separator:ac5638e205ed8f8a1473d3b866e9a7d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7b7939c050afa7475e249e06961e75"><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7e7b7939c050afa7475e249e06961e75">settingsFilePath</a></td></tr>
<tr class="memdesc:a7e7b7939c050afa7475e249e06961e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full name of the file containing machine settings data.  <br /></td></tr>
<tr class="separator:a7e7b7939c050afa7475e249e06961e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce080a3b082fea41b9ba7f3b9c7c716"><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#afce080a3b082fea41b9ba7f3b9c7c716">settingsAuxFilePath</a></td></tr>
<tr class="memdesc:afce080a3b082fea41b9ba7f3b9c7c716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full name of the file containing auxiliary machine settings data.  <br /></td></tr>
<tr class="separator:afce080a3b082fea41b9ba7f3b9c7c716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa04613f860573400ba570fcf80f3ef"><td class="memItemLeft" align="right" valign="top">readonly attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7fa04613f860573400ba570fcf80f3ef">settingsModified</a></td></tr>
<tr class="memdesc:a7fa04613f860573400ba570fcf80f3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the settings of this machine have been modified (but neither yet saved nor discarded).  <br /></td></tr>
<tr class="separator:a7fa04613f860573400ba570fcf80f3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc00e3c014d4548a025e4eafff7056e"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="_virtual_box_8idl.html#ac82c179a797c0d7c249d1b98a8e3aa8f">SessionState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aecc00e3c014d4548a025e4eafff7056e">sessionState</a></td></tr>
<tr class="memdesc:aecc00e3c014d4548a025e4eafff7056e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current session state for this machine.  <br /></td></tr>
<tr class="separator:aecc00e3c014d4548a025e4eafff7056e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6b48e4903942bb0a356e5c081de870"><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#acc6b48e4903942bb0a356e5c081de870">sessionName</a></td></tr>
<tr class="memdesc:acc6b48e4903942bb0a356e5c081de870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the session.  <br /></td></tr>
<tr class="separator:acc6b48e4903942bb0a356e5c081de870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7380f79a10f9813dbced54f51004c6b5"><td class="memItemLeft" align="right" valign="top">readonly attribute unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7380f79a10f9813dbced54f51004c6b5">sessionPID</a></td></tr>
<tr class="memdesc:a7380f79a10f9813dbced54f51004c6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier of the session process.  <br /></td></tr>
<tr class="separator:a7380f79a10f9813dbced54f51004c6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9653e9d996d60fc54e8bed22179d92b2"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9eb">MachineState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a9653e9d996d60fc54e8bed22179d92b2">state</a></td></tr>
<tr class="memdesc:a9653e9d996d60fc54e8bed22179d92b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current execution state of this machine.  <br /></td></tr>
<tr class="separator:a9653e9d996d60fc54e8bed22179d92b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a96e177095b0f13c2fc43f425d9a45d"><td class="memItemLeft" align="right" valign="top">readonly attribute long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a3a96e177095b0f13c2fc43f425d9a45d">lastStateChange</a></td></tr>
<tr class="memdesc:a3a96e177095b0f13c2fc43f425d9a45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp of the last execution state change, in milliseconds since 1970-01-01 UTC.  <br /></td></tr>
<tr class="separator:a3a96e177095b0f13c2fc43f425d9a45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf84094ff47ad0f8f2517ee513eed02"><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a6bf84094ff47ad0f8f2517ee513eed02">stateFilePath</a></td></tr>
<tr class="memdesc:a6bf84094ff47ad0f8f2517ee513eed02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full path to the file that stores the execution state of the machine when it is in either the <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9ebac8fa7577db141baf9cc06279665f122b">MachineState_Saved</a><b></b> or <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9eba2e667c004d2a414418ebfbddb666e65b">MachineState_AbortedSaved</a><b></b> state.  <br /></td></tr>
<tr class="separator:a6bf84094ff47ad0f8f2517ee513eed02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27636df01fde10102799eec13416ab51"><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a27636df01fde10102799eec13416ab51">logFolder</a></td></tr>
<tr class="memdesc:a27636df01fde10102799eec13416ab51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full path to the folder that stores a set of rotated log files recorded during machine execution.  <br /></td></tr>
<tr class="separator:a27636df01fde10102799eec13416ab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac785dbe04eccc0793d949d6940202767"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_snapshot.html">ISnapshot</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ac785dbe04eccc0793d949d6940202767">currentSnapshot</a></td></tr>
<tr class="memdesc:ac785dbe04eccc0793d949d6940202767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current snapshot of this machine.  <br /></td></tr>
<tr class="separator:ac785dbe04eccc0793d949d6940202767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1946d487a58f17cf4ee78a28c64a50da"><td class="memItemLeft" align="right" valign="top">readonly attribute unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a1946d487a58f17cf4ee78a28c64a50da">snapshotCount</a></td></tr>
<tr class="memdesc:a1946d487a58f17cf4ee78a28c64a50da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of snapshots taken on this machine.  <br /></td></tr>
<tr class="separator:a1946d487a58f17cf4ee78a28c64a50da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141d87506c33bd09d7fad144ca52c871"><td class="memItemLeft" align="right" valign="top">readonly attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a141d87506c33bd09d7fad144ca52c871">currentStateModified</a></td></tr>
<tr class="memdesc:a141d87506c33bd09d7fad144ca52c871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the current state of the machine is not identical to the state stored in the current snapshot.  <br /></td></tr>
<tr class="separator:a141d87506c33bd09d7fad144ca52c871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d48e83d2a8b245afa00116b1e7ca37"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_shared_folder.html">ISharedFolder</a>[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab9d48e83d2a8b245afa00116b1e7ca37">sharedFolders</a></td></tr>
<tr class="memdesc:ab9d48e83d2a8b245afa00116b1e7ca37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of shared folders for this machine (permanent shared folders).  <br /></td></tr>
<tr class="separator:ab9d48e83d2a8b245afa00116b1e7ca37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21aa593375c45dcd5a7b4c3a2a73b5f"><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#a096d8cfa9dea55360b7d50c70176a222">ClipboardMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab21aa593375c45dcd5a7b4c3a2a73b5f">clipboardMode</a></td></tr>
<tr class="memdesc:ab21aa593375c45dcd5a7b4c3a2a73b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization mode between the host OS clipboard and the guest OS clipboard.  <br /></td></tr>
<tr class="separator:ab21aa593375c45dcd5a7b4c3a2a73b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ee7d598e66bb5ab87f496c3ea66d72"><td class="memItemLeft" align="right" valign="top">attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a12ee7d598e66bb5ab87f496c3ea66d72">clipboardFileTransfersEnabled</a></td></tr>
<tr class="memdesc:a12ee7d598e66bb5ab87f496c3ea66d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or retrieves whether clipboard file transfers are allowed or not.  <br /></td></tr>
<tr class="separator:a12ee7d598e66bb5ab87f496c3ea66d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161a779fa01e1ff5e50982205a32e805"><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#a6e9dd4a91e0d1048c9373e6eeb93aa4a">DnDMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a161a779fa01e1ff5e50982205a32e805">dnDMode</a></td></tr>
<tr class="memdesc:a161a779fa01e1ff5e50982205a32e805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or retrieves the current drag'n drop mode.  <br /></td></tr>
<tr class="separator:a161a779fa01e1ff5e50982205a32e805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662d92a1c47ac75f15a4660ae5247d22"><td class="memItemLeft" align="right" valign="top">attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a662d92a1c47ac75f15a4660ae5247d22">teleporterEnabled</a></td></tr>
<tr class="memdesc:a662d92a1c47ac75f15a4660ae5247d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">When set to <em>true</em>, the virtual machine becomes a target teleporter the next time it is powered on.  <br /></td></tr>
<tr class="separator:a662d92a1c47ac75f15a4660ae5247d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fb6bfa8fc01e46728d3c7ee716a237"><td class="memItemLeft" align="right" valign="top">attribute unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a45fb6bfa8fc01e46728d3c7ee716a237">teleporterPort</a></td></tr>
<tr class="memdesc:a45fb6bfa8fc01e46728d3c7ee716a237"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TCP port the target teleporter will listen for incoming teleportations on.  <br /></td></tr>
<tr class="separator:a45fb6bfa8fc01e46728d3c7ee716a237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8a33069ddcde81ba6928f11584cb3b"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a0f8a33069ddcde81ba6928f11584cb3b">teleporterAddress</a></td></tr>
<tr class="memdesc:a0f8a33069ddcde81ba6928f11584cb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address the target teleporter will listen on.  <br /></td></tr>
<tr class="separator:a0f8a33069ddcde81ba6928f11584cb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df9bcd55c58f6565e20833e50643e79"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7df9bcd55c58f6565e20833e50643e79">teleporterPassword</a></td></tr>
<tr class="memdesc:a7df9bcd55c58f6565e20833e50643e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">The password to check for on the target teleporter.  <br /></td></tr>
<tr class="separator:a7df9bcd55c58f6565e20833e50643e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cc37de9ba8da175b44e7c03baa34bd"><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#ad4d63f64a610fd190118618ceac0f6ee">ParavirtProvider</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a97cc37de9ba8da175b44e7c03baa34bd">paravirtProvider</a></td></tr>
<tr class="memdesc:a97cc37de9ba8da175b44e7c03baa34bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The paravirtualized guest interface provider.  <br /></td></tr>
<tr class="separator:a97cc37de9ba8da175b44e7c03baa34bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9999c5c9eb8eecac98a45bde62fc3bce"><td class="memItemLeft" align="right" valign="top">attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a9999c5c9eb8eecac98a45bde62fc3bce">IOCacheEnabled</a></td></tr>
<tr class="memdesc:a9999c5c9eb8eecac98a45bde62fc3bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">When set to <em>true</em>, the builtin I/O cache of the virtual machine will be enabled.  <br /></td></tr>
<tr class="separator:a9999c5c9eb8eecac98a45bde62fc3bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596ae3cdd7eea9f92c79dddd4c738f6f"><td class="memItemLeft" align="right" valign="top">attribute unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a596ae3cdd7eea9f92c79dddd4c738f6f">IOCacheSize</a></td></tr>
<tr class="memdesc:a596ae3cdd7eea9f92c79dddd4c738f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of the I/O cache in MB.  <br /></td></tr>
<tr class="separator:a596ae3cdd7eea9f92c79dddd4c738f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a5c9476de084724b89fda4ea26ae12"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_p_c_i_device_attachment.html">IPCIDeviceAttachment</a>[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a38a5c9476de084724b89fda4ea26ae12">PCIDeviceAssignments</a></td></tr>
<tr class="memdesc:a38a5c9476de084724b89fda4ea26ae12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of PCI devices assigned to this machine, to get list of all PCI devices attached to the machine use <a class="el" href="interface_i_console.html#a6d41c200e67a37cdbc9c270317831774">IConsole::attachedPCIDevices</a><b></b> attribute, as this attribute is intended to list only devices additional to what described in virtual hardware config.  <br /></td></tr>
<tr class="separator:a38a5c9476de084724b89fda4ea26ae12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c8725d2d0bf1bc99d3fc2048dfe98a"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_bandwidth_control.html">IBandwidthControl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a15c8725d2d0bf1bc99d3fc2048dfe98a">bandwidthControl</a></td></tr>
<tr class="memdesc:a15c8725d2d0bf1bc99d3fc2048dfe98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bandwidth control manager.  <br /></td></tr>
<tr class="separator:a15c8725d2d0bf1bc99d3fc2048dfe98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08618a97a181c10f9113b3844d6ae577"><td class="memItemLeft" align="right" valign="top">attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a08618a97a181c10f9113b3844d6ae577">tracingEnabled</a></td></tr>
<tr class="memdesc:a08618a97a181c10f9113b3844d6ae577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the tracing facility in the VMM (including PDM devices + drivers).  <br /></td></tr>
<tr class="separator:a08618a97a181c10f9113b3844d6ae577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4ec9af3f5705deed580ccba5a2e142"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2f4ec9af3f5705deed580ccba5a2e142">tracingConfig</a></td></tr>
<tr class="memdesc:a2f4ec9af3f5705deed580ccba5a2e142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracepoint configuration to apply at startup when <a class="el" href="interface_i_machine.html#a08618a97a181c10f9113b3844d6ae577">IMachine::tracingEnabled</a><b></b> is true.  <br /></td></tr>
<tr class="separator:a2f4ec9af3f5705deed580ccba5a2e142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa33f6952f420c0163dd2eefccc62ed"><td class="memItemLeft" align="right" valign="top">attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#acfa33f6952f420c0163dd2eefccc62ed">allowTracingToAccessVM</a></td></tr>
<tr class="memdesc:acfa33f6952f420c0163dd2eefccc62ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables tracepoints in PDM devices and drivers to use the VMCPU or VM structures when firing off trace points.  <br /></td></tr>
<tr class="separator:acfa33f6952f420c0163dd2eefccc62ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5154cad0ba95af8d3ce358571222bc"><td class="memItemLeft" align="right" valign="top">attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aca5154cad0ba95af8d3ce358571222bc">autostartEnabled</a></td></tr>
<tr class="memdesc:aca5154cad0ba95af8d3ce358571222bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables autostart of the VM during system boot.  <br /></td></tr>
<tr class="separator:aca5154cad0ba95af8d3ce358571222bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d371d975c607f0d3f81ab57459149df"><td class="memItemLeft" align="right" valign="top">attribute unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a9d371d975c607f0d3f81ab57459149df">autostartDelay</a></td></tr>
<tr class="memdesc:a9d371d975c607f0d3f81ab57459149df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of seconds to wait until the VM should be started during system boot.  <br /></td></tr>
<tr class="separator:a9d371d975c607f0d3f81ab57459149df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724adf774f12d25744bbac488c7fe26e"><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#a03ad7f2af3ceb813a15cdc614db93c73">AutostopType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a724adf774f12d25744bbac488c7fe26e">autostopType</a></td></tr>
<tr class="memdesc:a724adf774f12d25744bbac488c7fe26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Action type to do when the system is shutting down.  <br /></td></tr>
<tr class="separator:a724adf774f12d25744bbac488c7fe26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219a6cc56c7488c1873418e49dfd2c69"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a219a6cc56c7488c1873418e49dfd2c69">defaultFrontend</a></td></tr>
<tr class="memdesc:a219a6cc56c7488c1873418e49dfd2c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects which VM frontend should be used by default when launching this VM through the <a class="el" href="interface_i_machine.html#aa75e76da42ef908795d235d995262c6f">IMachine::launchVMProcess</a><b></b> method.  <br /></td></tr>
<tr class="separator:a219a6cc56c7488c1873418e49dfd2c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07caab27f0c5c1eca2e513dc2f29be7"><td class="memItemLeft" align="right" valign="top">readonly attribute boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af07caab27f0c5c1eca2e513dc2f29be7">USBProxyAvailable</a></td></tr>
<tr class="memdesc:af07caab27f0c5c1eca2e513dc2f29be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there is a USB proxy available.  <br /></td></tr>
<tr class="separator:af07caab27f0c5c1eca2e513dc2f29be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d9918ca129ee856a9e17004a3c6daa"><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#acc3c8270a58faac4d5121d99a8549c49">VMProcPriority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ac3d9918ca129ee856a9e17004a3c6daa">VMProcessPriority</a></td></tr>
<tr class="memdesc:ac3d9918ca129ee856a9e17004a3c6daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the priority of the VM process.  <br /></td></tr>
<tr class="separator:ac3d9918ca129ee856a9e17004a3c6daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d572badb3f0a926770566b3d1795e7"><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#aa6b799bf0e81e1dcaeb02803c36f510f">VMExecutionEngine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a87d572badb3f0a926770566b3d1795e7">VMExecutionEngine</a></td></tr>
<tr class="memdesc:a87d572badb3f0a926770566b3d1795e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configured VM execution engine.  <br /></td></tr>
<tr class="separator:a87d572badb3f0a926770566b3d1795e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ef62440037c084157ace16494cc563"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a15ef62440037c084157ace16494cc563">paravirtDebug</a></td></tr>
<tr class="memdesc:a15ef62440037c084157ace16494cc563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug parameters for the paravirtualized guest interface provider.  <br /></td></tr>
<tr class="separator:a15ef62440037c084157ace16494cc563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c497fcc86cb5a515646287080feea9"><td class="memItemLeft" align="right" valign="top">attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ae0c497fcc86cb5a515646287080feea9">CPUProfile</a></td></tr>
<tr class="memdesc:ae0c497fcc86cb5a515646287080feea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental feature to select the guest CPU profile.  <br /></td></tr>
<tr class="separator:ae0c497fcc86cb5a515646287080feea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38718ba046f8462f325647afd52f7cd3"><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a38718ba046f8462f325647afd52f7cd3">stateKeyId</a></td></tr>
<tr class="memdesc:a38718ba046f8462f325647afd52f7cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key Id of the password used for encrypting the state file.  <br /></td></tr>
<tr class="separator:a38718ba046f8462f325647afd52f7cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6eb3f6087a43cd1721ee7a659d8a6a"><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7a6eb3f6087a43cd1721ee7a659d8a6a">stateKeyStore</a></td></tr>
<tr class="memdesc:a7a6eb3f6087a43cd1721ee7a659d8a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key store used for encrypting the state file.  <br /></td></tr>
<tr class="separator:a7a6eb3f6087a43cd1721ee7a659d8a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bee1a4d7d9b271b77f063757f426e9a"><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2bee1a4d7d9b271b77f063757f426e9a">logKeyId</a></td></tr>
<tr class="memdesc:a2bee1a4d7d9b271b77f063757f426e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key Id of the password used for encrypting the log files.  <br /></td></tr>
<tr class="separator:a2bee1a4d7d9b271b77f063757f426e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c13e46eb7de7852226047dc5aeca66"><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a08c13e46eb7de7852226047dc5aeca66">logKeyStore</a></td></tr>
<tr class="memdesc:a08c13e46eb7de7852226047dc5aeca66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key store used for encrypting the log files.  <br /></td></tr>
<tr class="separator:a08c13e46eb7de7852226047dc5aeca66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ccc2041a103f76e978fce989e911b5"><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_guest_debug_control.html">IGuestDebugControl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a76ccc2041a103f76e978fce989e911b5">guestDebugControl</a></td></tr>
<tr class="memdesc:a76ccc2041a103f76e978fce989e911b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guest debugging configuration.  <br /></td></tr>
<tr class="separator:a76ccc2041a103f76e978fce989e911b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> interface represents a virtual machine, or guest, created in VirtualBox. </p>
<p>This interface is used in two contexts. First of all, a collection of objects implementing this interface is stored in the <a class="el" href="interface_i_virtual_box.html#aad58f4626e004e340e418dae6f4cd1c0">IVirtualBox::machines</a><b></b> attribute which lists all the virtual machines that are currently registered with this VirtualBox installation. Also, once a session has been opened for the given virtual machine (e.g. the virtual machine is running), the machine object associated with the open session can be queried from the session object; see <a class="el" href="interface_i_session.html">ISession</a><b></b> for details.</p>
<p>The main role of this interface is to expose the settings of the virtual machine and provide methods to change various aspects of the virtual machine's configuration. For machine objects stored in the <a class="el" href="interface_i_virtual_box.html#aad58f4626e004e340e418dae6f4cd1c0">IVirtualBox::machines</a><b></b> collection, all attributes are read-only unless explicitly stated otherwise in individual attribute and method descriptions.</p>
<p>In order to change a machine setting, a session for this machine must be opened using one of the <a class="el" href="interface_i_machine.html#af28da645b00a821547d9cb8e92f8b7b0">IMachine::lockMachine</a><b></b> or <a class="el" href="interface_i_machine.html#aa75e76da42ef908795d235d995262c6f">IMachine::launchVMProcess</a><b></b> methods. After the machine has been successfully locked for a session, a mutable machine object needs to be queried from the session object and then the desired settings changes can be applied to the returned object using <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> attributes and methods. See the <a class="el" href="interface_i_session.html">ISession</a><b></b> interface description for more information about sessions.</p>
<p>Note that <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> does not provide methods to control virtual machine execution (such as start the machine, or power it down) &ndash; these methods are grouped in a separate interface called <a class="el" href="interface_i_console.html">IConsole</a><b></b>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_i_session.html">ISession</a><b></b>, <a class="el" href="interface_i_console.html">IConsole</a><b></b></dd></dl>
<dl class="section user"><dt>Interface ID:</dt><dd><code>{E36A5081-A82A-40BD-9E4E-42A44D6CE50F}</code> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af28da645b00a821547d9cb8e92f8b7b0" name="af28da645b00a821547d9cb8e92f8b7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28da645b00a821547d9cb8e92f8b7b0">&#9670;&#160;</a></span>lockMachine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::lockMachine </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_session.html">ISession</a>&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a5893ac36dd21da7bcd19a505205ea180">LockType</a>&#160;</td>
          <td class="paramname"><em>lockType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the machine for the given session to enable the caller to make changes to the machine or start the VM or control VM execution. </p>
<p>There are two ways to lock a machine for such uses:</p>
<ul>
<li>
<p class="startli">If you want to make changes to the machine settings, you must obtain an exclusive write lock on the machine by setting <em>lockType</em> to <code>Write</code>.</p>
<p class="interli">This will only succeed if no other process has locked the machine to prevent conflicting changes. Only after an exclusive write lock has been obtained using this method, one can change all VM settings or execute the VM in the process space of the session object. (Note that the latter is only of interest if you actually want to write a new front-end for virtual machines; but this API gets called internally by the existing front-ends such as VBoxHeadless and the VirtualBox GUI to acquire a write lock on the machine that they are running.)</p>
<p class="endli">On success, write-locking the machine for a session creates a second copy of the <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> object. It is this second object upon which changes can be made; in VirtualBox terminology, the second copy is "mutable". It is only this second, mutable machine object upon which you can call methods that change the machine state. After having called this method, you can obtain this second, mutable machine object using the <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b> attribute. </p>
</li>
<li>
<p class="startli">If you only want to check the machine state or control machine execution without actually changing machine settings (e.g. to get access to VM statistics or take a snapshot or save the machine state), then set the <em>lockType</em> argument to <code>Shared</code>.</p>
<p class="interli">If no other session has obtained a lock, you will obtain an exclusive write lock as described above. However, if another session has already obtained such a lock, then a link to that existing session will be established which allows you to control that existing session.</p>
<p class="endli">To find out which type of lock was obtained, you can inspect <a class="el" href="interface_i_session.html#ac3ce0abc5951d6e244c456518d7574b1">ISession::type</a><b></b>, which will have been set to either <code>WriteLock</code> or <code>Shared</code>. </p>
</li>
</ul>
<p>In either case, you can get access to the <a class="el" href="interface_i_console.html">IConsole</a><b></b> object which controls VM execution.</p>
<p>Also in all of the above cases, one must always call <a class="el" href="interface_i_session.html#a87571b3c87d705ee013b24f135f43715">ISession::unlockMachine</a><b></b> to release the lock on the machine, or the machine's state will eventually be set to "Aborted".</p>
<p>To change settings on a machine, the following sequence is typically performed:</p>
<ol>
<li>
Call this method to obtain an exclusive write lock for the current session.</li>
<li>
Obtain a mutable <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> object from <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b>.</li>
<li>
Change the settings of the machine by invoking <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> methods.</li>
<li>
Call <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">IMachine::saveSettings</a><b></b>.</li>
<li>
Release the write lock by calling <a class="el" href="interface_i_session.html#a87571b3c87d705ee013b24f135f43715">ISession::unlockMachine</a><b></b>.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>Session object for which the machine will be locked.</td></tr>
    <tr><td class="paramname">lockType</td><td>If set to <code>Write</code>, then attempt to acquire an exclusive write lock or fail. If set to <code>Shared</code>, then either acquire an exclusive write lock or establish a link to an existing session.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_UNEXPECTED</td><td>Virtual machine not registered. </td></tr>
<tr>
<td>E_ACCESSDENIED</td><td>Process not started by <a class="el" href="interface_i_machine.html#aa75e76da42ef908795d235d995262c6f">IMachine::launchVMProcess</a><b></b>. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Session already open or being opened. </td></tr>
<tr>
<td>VBOX_E_VM_ERROR</td><td>Failed to assign machine to session. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aa75e76da42ef908795d235d995262c6f" name="aa75e76da42ef908795d235d995262c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75e76da42ef908795d235d995262c6f">&#9670;&#160;</a></span>launchVMProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::launchVMProcess </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_session.html">ISession</a>&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring[]&#160;</td>
          <td class="paramname"><em>environmentChanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns a new process that will execute the virtual machine and obtains a shared lock on the machine for the calling session. </p>
<p>If launching the VM succeeds, the new VM process will create its own session and write-lock the machine for it, preventing conflicting changes from other processes. If the machine is already locked (because it is already running or because another session has a write lock), launching the VM process will therefore fail. Reversely, future attempts to obtain a write lock will also fail while the machine is running.</p>
<p>The caller's session object remains separate from the session opened by the new VM process. It receives its own <a class="el" href="interface_i_console.html">IConsole</a><b></b> object which can be used to control machine execution, but it cannot be used to change all VM settings which would be available after a <a class="el" href="interface_i_machine.html#af28da645b00a821547d9cb8e92f8b7b0">lockMachine</a><b></b> call.</p>
<p>The caller must eventually release the session's shared lock by calling <a class="el" href="interface_i_session.html#a87571b3c87d705ee013b24f135f43715">ISession::unlockMachine</a><b></b> on the local session object once this call has returned. However, the session's state (see <a class="el" href="interface_i_session.html#aac4763cc59a693a81170ed9d1118d571">ISession::state</a><b></b>) will not return to "Unlocked" until the remote session has also unlocked the machine (i.e. the machine has stopped running).</p>
<p>Launching a VM process can take some time (a new VM is started in a new process, for which memory and other resources need to be set up). Because of this, an <a class="el" href="interface_i_progress.html">IProgress</a><b></b> object is returned to allow the caller to wait for this asynchronous operation to be completed. Until then, the caller's session object remains in the "Unlocked" state, and its <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b> and <a class="el" href="interface_i_session.html#a9e36ef0b77cc8ef17fbe480f39492fad">ISession::console</a><b></b> attributes cannot be accessed. It is recommended to use <a class="el" href="interface_i_progress.html#a77f58c52e91008021222943dccff35b1">IProgress::waitForCompletion</a><b></b> or similar calls to wait for completion. Completion is signalled when the VM is powered on. If launching the VM fails, error messages can be queried via the progress object, if available.</p>
<p>The progress object will have at least 2 sub-operations. The first operation covers the period up to the new VM process calls powerUp. The subsequent operations mirror the <a class="el" href="interface_i_console.html#a0191f0ffb739504065c05f6e33a65a7c">IConsole::powerUp</a><b></b> progress object. Because <a class="el" href="interface_i_console.html#a0191f0ffb739504065c05f6e33a65a7c">IConsole::powerUp</a><b></b> may require some extra sub-operations, the <a class="el" href="interface_i_progress.html#a38681d42e827d029c89587269ab76845">IProgress::operationCount</a><b></b> may change at the completion of operation.</p>
<p>For details on the teleportation progress operation, see <a class="el" href="interface_i_console.html#a0191f0ffb739504065c05f6e33a65a7c">IConsole::powerUp</a><b></b>.</p>
<p>The <em>environmentChanges</em> argument is a list of strings where every string contains environment variable in the putenv style, i.e. "VAR=VALUE" for setting/replacing and "VAR" for unsetting. These environment variables will be applied to the environment of the VirtualBox server process. If an environment variable exists both in the server process and in this list, the value from this list takes precedence over the server's variable. If the value of the environment variable is omitted, this variable will be removed from the resulting environment. If the list is empty, the server environment is inherited by the started process as is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>Client session object to which the VM process will be connected (this must be in "Unlocked" state).</td></tr>
    <tr><td class="paramname">name</td><td>Front-end to use for the new VM process. The following are currently supported:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>
<code>"gui"</code>: VirtualBox Qt GUI front-end</li>
<li>
<code>"headless"</code>: VBoxHeadless (VRDE Server) front-end</li>
<li>
<code>"sdl"</code>: VirtualBox SDL front-end</li>
<li>
<code>"emergencystop"</code>: reserved value, used for aborting the currently running VM or session owner. In this case the <em>session</em> parameter may be <code>null</code> (if it is non-null it isn't used in any way), and the <em>progress</em> return value will be always <code>null</code>. The operation completes immediately.</li>
<li>
<code>""</code>: use the per-VM default frontend if set, otherwise the global default defined in the system properties. If neither are set, the API will launch a <code>"gui"</code> session, which may fail if there is no windowing environment available. See <a class="el" href="interface_i_machine.html#a219a6cc56c7488c1873418e49dfd2c69">IMachine::defaultFrontend</a><b></b> and <a class="el" href="interface_i_system_properties.html#aa78a4624ed0d220db7a47a038b818194">ISystemProperties::defaultFrontend</a><b></b>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">environmentChanges</td><td>The list of putenv-style changes to the VM process environment.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_UNEXPECTED</td><td>Virtual machine not registered. </td></tr>
<tr>
<td>E_INVALIDARG</td><td>Invalid session type <em>type</em>. </td></tr>
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>No machine matching <em>machineId</em> found. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Session already open or being opened. </td></tr>
<tr>
<td>VBOX_E_IPRT_ERROR</td><td>Launching process for machine failed. </td></tr>
<tr>
<td>VBOX_E_VM_ERROR</td><td>Failed to assign machine to session. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="af21be3d39450fb895a1547c87636d40a" name="af21be3d39450fb895a1547c87636d40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21be3d39450fb895a1547c87636d40a">&#9670;&#160;</a></span>setBootOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setBootOrder </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the given device to the specified position in the boot order. </p>
<p>To indicate that no device is associated with the given position, <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9adcea7b56c801ff3aecd5e54d0f24c8cb">DeviceType_Null</a><b></b> should be used.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>setHardDiskBootOrder(), setNetworkBootOrder()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position in the boot order (<code>1</code> to the total number of devices the machine can boot from, as returned by <a class="el" href="interface_i_platform_properties.html#aa9db3a7901507491ac39fa8f14cc05ae">IPlatformProperties::maxBootPosition</a><b></b>).</td></tr>
    <tr><td class="paramname">device</td><td>The type of the device used to boot at the given position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>Boot <em>position</em> out of range. </td></tr>
<tr>
<td>E_NOTIMPL</td><td>Booting from USB <em>device</em> currently not supported. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a8e106050b4d54f39836230719ad07e14" name="a8e106050b4d54f39836230719ad07e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e106050b4d54f39836230719ad07e14">&#9670;&#160;</a></span>getBootOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getBootOrder </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the device type that occupies the specified position in the boot order. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>[remove?] If the machine can have more than one device of the returned type (such as hard disks), then a separate method should be used to retrieve the individual device that occupies the given position.</dd></dl>
<p>If here are no devices at the given position, then <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9adcea7b56c801ff3aecd5e54d0f24c8cb">DeviceType_Null</a><b></b> is returned.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>getHardDiskBootOrder(), getNetworkBootOrder()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position in the boot order (<code>1</code> to the total number of devices the machine can boot from, as returned by <a class="el" href="interface_i_platform_properties.html#aa9db3a7901507491ac39fa8f14cc05ae">IPlatformProperties::maxBootPosition</a><b></b>).</td></tr>
    <tr><td class="paramname">device</td><td>Device at the given position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>Boot <em>position</em> out of range. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a8e51fafec7442a48a86a59edec5ec217" name="a8e51fafec7442a48a86a59edec5ec217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e51fafec7442a48a86a59edec5ec217">&#9670;&#160;</a></span>attachDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::attachDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="interface_i_medium.html">IMedium</a>&#160;</td>
          <td class="paramname"><em>medium</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a device and optionally mounts a medium to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device. </p>
<p>This method is intended for managing storage devices in general while a machine is powered off. It can be used to attach and detach fixed and removable media. The following kind of media can be attached to a machine:</p>
<ul>
<li>
For fixed and removable media, you can pass in a medium that was previously opened using <a class="el" href="interface_i_virtual_box.html#a5336442d7ee9b95e4500b5f6e657bcb7">IVirtualBox::openMedium</a><b></b>. </li>
<li>
Only for storage devices supporting removable media (such as DVDs and floppies), you can also specify a null pointer to indicate an empty drive or one of the medium objects listed in the <a class="el" href="interface_i_host.html#a285b1b89c35b67a0bb52b547f5d3ebb3">IHost::DVDDrives</a><b></b> and <a class="el" href="interface_i_host.html#ade0e3923823c0c8d96e7eac39748122c">IHost::floppyDrives</a><b></b> arrays to indicate a host drive. For removable devices, you can also use <a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">IMachine::mountMedium</a><b></b> to change the media while the machine is running. </li>
</ul>
<p>In a VM's default configuration of virtual machines, the secondary master of the IDE controller is used for a CD/DVD drive.</p>
<p>After calling this returns successfully, a new instance of <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b> will appear in the machine's list of medium attachments (see <a class="el" href="interface_i_machine.html#aef972b7f8785c3a3f98a592a246ca4b4">IMachine::mediumAttachments</a><b></b>).</p>
<p>See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> and <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b> for more information about attaching media.</p>
<p>The specified device slot must not have a device attached to it, or this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller to attach the device to.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Port to attach the device to. For an IDE controller, 0 specifies the primary controller and 1 specifies the secondary controller. For a SCSI controller, this must range from 0 to 15; for a SATA controller, from 0 to 29; for an SAS controller, from 0 to 7.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port to attach the device to. This is only relevant for IDE controllers, for which 0 specifies the master device and 1 specifies the slave device. For all other controller types, this must be 0.</td></tr>
    <tr><td class="paramname">type</td><td>Device type of the attached device. For media opened by <a class="el" href="interface_i_virtual_box.html#a5336442d7ee9b95e4500b5f6e657bcb7">IVirtualBox::openMedium</a><b></b>, this must match the device type specified there.</td></tr>
    <tr><td class="paramname">medium</td><td>Medium to mount or <code>null</code> for an empty drive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, IDE port or IDE slot out of range, or file or UUID not found. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Machine must be registered before media can be attached. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
<tr>
<td>VBOX_E_OBJECT_IN_USE</td><td>A medium is already attached to this or another virtual machine. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You cannot attach a device to a newly created machine until this machine's settings are saved to disk using <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b>.</dd>
<dd>
If the medium is being attached indirectly, a new differencing medium will implicitly be created for it and attached instead. If the changes made to the machine settings (including this indirect attachment) are later cancelled using <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>, this implicitly created differencing medium will implicitly be deleted. </dd></dl>

</div>
</div>
<a id="ad4f8c3614866c1fe78c30357d6e70146" name="ad4f8c3614866c1fe78c30357d6e70146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f8c3614866c1fe78c30357d6e70146">&#9670;&#160;</a></span>attachDeviceWithoutMedium()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::attachDeviceWithoutMedium </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a device and optionally mounts a medium to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device. </p>
<p>This method is intended for managing storage devices in general while a machine is powered off. It can be used to attach and detach fixed and removable media. The following kind of media can be attached to a machine:</p>
<ul>
<li>
For fixed and removable media, you can pass in a medium that was previously opened using <a class="el" href="interface_i_virtual_box.html#a5336442d7ee9b95e4500b5f6e657bcb7">IVirtualBox::openMedium</a><b></b>. </li>
<li>
Only for storage devices supporting removable media (such as DVDs and floppies) with an empty drive or one of the medium objects listed in the <a class="el" href="interface_i_host.html#a285b1b89c35b67a0bb52b547f5d3ebb3">IHost::DVDDrives</a><b></b> and <a class="el" href="interface_i_host.html#ade0e3923823c0c8d96e7eac39748122c">IHost::floppyDrives</a><b></b> arrays to indicate a host drive. For removable devices, you can also use <a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">IMachine::mountMedium</a><b></b> to change the media while the machine is running. </li>
</ul>
<p>In a VM's default configuration of virtual machines, the secondary master of the IDE controller is used for a CD/DVD drive. <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b> will appear in the machine's list of medium attachments (see <a class="el" href="interface_i_machine.html#aef972b7f8785c3a3f98a592a246ca4b4">IMachine::mediumAttachments</a><b></b>).</p>
<p>See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> and <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b> for more information about attaching media.</p>
<p>The specified device slot must not have a device attached to it, or this method will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller to attach the device to.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Port to attach the device to. For an IDE controller, 0 specifies the primary controller and 1 specifies the secondary controller. For a SCSI controller, this must range from 0 to 15; for a SATA controller, from 0 to 29; for an SAS controller, from 0 to 7.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port to attach the device to. This is only relevant for IDE controllers, for which 0 specifies the master device and 1 specifies the slave device. For all other controller types, this must be 0.</td></tr>
    <tr><td class="paramname">type</td><td>Device type of the attached device. For media opened by <a class="el" href="interface_i_virtual_box.html#a5336442d7ee9b95e4500b5f6e657bcb7">IVirtualBox::openMedium</a><b></b>, this must match the device type specified there.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, IDE port or IDE slot out of range, or file or UUID not found. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Machine must be registered before media can be attached. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
<tr>
<td>VBOX_E_OBJECT_IN_USE</td><td>A medium is already attached to this or another virtual machine. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You cannot attach a device to a newly created machine until this machine's settings are saved to disk using <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b>.</dd>
<dd>
If the medium is being attached indirectly, a new differencing medium will implicitly be created for it and attached instead. If the changes made to the machine settings (including this indirect attachment) are later cancelled using <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>, this implicitly created differencing medium will implicitly be deleted. </dd></dl>

</div>
</div>
<a id="a59a8e406027e901cc260488f8617fb22" name="a59a8e406027e901cc260488f8617fb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a8e406027e901cc260488f8617fb22">&#9670;&#160;</a></span>detachDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::detachDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the device attached to a device slot of the specified bus. </p>
<p>Detaching the device from the virtual machine is deferred. This means that the medium remains associated with the machine when this method returns and gets actually de-associated only after a successful <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> call. See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> for more detailed information about attaching media.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller to detach the medium from.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Port number to detach the medium from.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot number to detach the medium from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Attempt to detach medium from a running virtual machine. </td></tr>
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>No medium attached to given slot/bus. </td></tr>
<tr>
<td>VBOX_E_NOT_SUPPORTED</td><td>Medium format does not support storage deletion (only for implicitly created differencing media, should not happen). </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You cannot detach a device from a running machine.</dd>
<dd>
Detaching differencing media implicitly created by <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">attachDevice</a><b></b> for the indirect attachment using this method will <b>not</b> implicitly delete them. The <a class="el" href="interface_i_medium.html#a94d118ff3f2ad05638d4c705532f0dce">IMedium::deleteStorage</a><b></b> operation should be explicitly performed by the caller after the medium is successfully detached and the settings are saved with <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b>, if it is the desired action. </dd></dl>

</div>
</div>
<a id="af0e34af9e99e5884bf0b2eb297344c92" name="af0e34af9e99e5884bf0b2eb297344c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e34af9e99e5884bf0b2eb297344c92">&#9670;&#160;</a></span>passthroughDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::passthroughDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>passthrough</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the passthrough mode of an existing DVD device. </p>
<p>Changing the setting while the VM is running is forbidden. The setting is only used if at VM start the device is configured as a host DVD drive, in all other cases it is ignored. The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Storage controller port.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port.</td></tr>
    <tr><td class="paramname">passthrough</td><td>New value for the passthrough setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, IDE port or IDE slot out of range. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Attempt to modify an unregistered virtual machine. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ab2883fc2f65c753bdc1d0ba22cd773c8" name="ab2883fc2f65c753bdc1d0ba22cd773c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2883fc2f65c753bdc1d0ba22cd773c8">&#9670;&#160;</a></span>temporaryEjectDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::temporaryEjectDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>temporaryEject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the behavior for guest-triggered medium eject. </p>
<p>In some situations it is desirable that such ejects update the VM configuration, and in others the eject should keep the VM configuration. The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Storage controller port.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port.</td></tr>
    <tr><td class="paramname">temporaryEject</td><td>New value for the eject behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, IDE port or IDE slot out of range. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Attempt to modify an unregistered virtual machine. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aa31ab8471f5076792487779533a26df0" name="aa31ab8471f5076792487779533a26df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31ab8471f5076792487779533a26df0">&#9670;&#160;</a></span>nonRotationalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::nonRotationalDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>nonRotational</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a flag in the device information which indicates that the medium is not based on rotational technology, i.e. </p>
<p>that the access times are more or less independent of the position on the medium. This may or may not be supported by a particular drive, and is silently ignored in the latter case. At the moment only hard disks (which is a misnomer in this context) accept this setting. Changing the setting while the VM is running is forbidden. The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Storage controller port.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port.</td></tr>
    <tr><td class="paramname">nonRotational</td><td>New value for the non-rotational device flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, IDE port or IDE slot out of range. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Attempt to modify an unregistered virtual machine. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aa02655252429d66d75188bcc56e41e7d" name="aa02655252429d66d75188bcc56e41e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02655252429d66d75188bcc56e41e7d">&#9670;&#160;</a></span>setAutoDiscardForDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setAutoDiscardForDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>discard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a flag in the device information which indicates that the medium supports discarding unused blocks (called trimming for SATA or unmap for SCSI devices) .This may or may not be supported by a particular drive, and is silently ignored in the latter case. </p>
<p>At the moment only hard disks (which is a misnomer in this context) accept this setting. Changing the setting while the VM is running is forbidden. The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Storage controller port.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port.</td></tr>
    <tr><td class="paramname">discard</td><td>New value for the discard device flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, SCSI port out of range. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Attempt to modify an unregistered virtual machine. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a9c00b608a08986ee8e50555e59ae4214" name="a9c00b608a08986ee8e50555e59ae4214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c00b608a08986ee8e50555e59ae4214">&#9670;&#160;</a></span>setHotPluggableForDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setHotPluggableForDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>hotPluggable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a flag in the device information which indicates that the attached device is hot pluggable or not. </p>
<p>This may or may not be supported by a particular controller and/or drive, and is silently ignored in the latter case. Changing the setting while the VM is running is forbidden. The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Storage controller port.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port.</td></tr>
    <tr><td class="paramname">hotPluggable</td><td>New value for the hot-pluggable device flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, IDE port or IDE slot out of range. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Attempt to modify an unregistered virtual machine. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
<tr>
<td>VBOX_E_NOT_SUPPORTED</td><td>Controller doesn't support hot plugging. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aa8ed8a03befa534d4df3c5342bf7fcf8" name="aa8ed8a03befa534d4df3c5342bf7fcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ed8a03befa534d4df3c5342bf7fcf8">&#9670;&#160;</a></span>setBandwidthGroupForDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setBandwidthGroupForDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="interface_i_bandwidth_group.html">IBandwidthGroup</a>&#160;</td>
          <td class="paramname"><em>bandwidthGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bandwidth group of an existing storage device. </p>
<p>The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Storage controller port.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port.</td></tr>
    <tr><td class="paramname">bandwidthGroup</td><td>New value for the bandwidth group or <code>null</code> for no group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, IDE port or IDE slot out of range. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Attempt to modify an unregistered virtual machine. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a94c2637db1f0f0fe4a687a4c2c245218" name="a94c2637db1f0f0fe4a687a4c2c245218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c2637db1f0f0fe4a687a4c2c245218">&#9670;&#160;</a></span>setNoBandwidthGroupForDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setNoBandwidthGroupForDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets no bandwidth group for an existing storage device. </p>
<p>The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device. The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Storage controller port.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, IDE port or IDE slot out of range. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Attempt to modify an unregistered virtual machine. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a1f3da9c7f26b4c630f3989f98b58515a" name="a1f3da9c7f26b4c630f3989f98b58515a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3da9c7f26b4c630f3989f98b58515a">&#9670;&#160;</a></span>unmountMedium()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::unmountMedium </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmounts any currently mounted medium (<a class="el" href="interface_i_medium.html">IMedium</a><b></b>, identified by the given UUID <em>id</em>) to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device. </p>
<p>The device must already exist;</p>
<p>This method is intended only for managing removable media, where the device is fixed but media is changeable at runtime (such as DVDs and floppies). It cannot be used for fixed media such as hard disks.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<p>The specified device slot must have a medium mounted, which will be unmounted. If there is no mounted medium it will do nothing. See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> for more detailed information about attaching/unmounting media.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller to unmount the medium from.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Port to unmount the medium from.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port to unmount the medium from.</td></tr>
    <tr><td class="paramname">force</td><td>Allows to force unmount of a medium which is locked by the device slot in the given port medium is attached to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, IDE port or IDE slot out of range. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Attempt to unmount medium that is not removable - not DVD or floppy. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
<tr>
<td>VBOX_E_OBJECT_IN_USE</td><td>Medium already attached to this or another virtual machine. </td></tr>
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>Medium not attached to specified port, device, controller. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a1c82306d3603e3bb40f6ab7467d4ff18" name="a1c82306d3603e3bb40f6ab7467d4ff18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c82306d3603e3bb40f6ab7467d4ff18">&#9670;&#160;</a></span>mountMedium()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::mountMedium </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="interface_i_medium.html">IMedium</a>&#160;</td>
          <td class="paramname"><em>medium</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts a medium (<a class="el" href="interface_i_medium.html">IMedium</a><b></b>, identified by the given UUID <em>id</em>) to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device. </p>
<p>The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>This method is intended only for managing removable media, where the device is fixed but media is changeable at runtime (such as DVDs and floppies). It cannot be used for fixed media such as hard disks.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<p>The specified device slot can have a medium mounted, which will be unmounted first. Specifying a zero UUID (or an empty string) for <em>medium</em> does just an unmount.</p>
<p>See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> for more detailed information about attaching media.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller to attach the medium to.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Port to attach the medium to.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port to attach the medium to.</td></tr>
    <tr><td class="paramname">medium</td><td>Medium to mount or <code>null</code> for an empty drive.</td></tr>
    <tr><td class="paramname">force</td><td>Allows to force unmount/mount of a medium which is locked by the device slot in the given port to attach the medium to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>SATA device, SATA port, IDE port or IDE slot out of range. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Attempt to attach medium to an unregistered virtual machine. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Invalid machine state. </td></tr>
<tr>
<td>VBOX_E_OBJECT_IN_USE</td><td>Medium already attached to this or another virtual machine. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ac3fb22d03a2c75b298ce1ec0ae1dc154" name="ac3fb22d03a2c75b298ce1ec0ae1dc154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fb22d03a2c75b298ce1ec0ae1dc154">&#9670;&#160;</a></span>getMedium()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getMedium </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_medium.html">IMedium</a>&#160;</td>
          <td class="paramname"><em>medium</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the virtual medium attached to a device slot of the specified bus. </p>
<p>Note that if the medium was indirectly attached by <a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">mountMedium</a><b></b> to the given device slot then this method will return not the same object as passed to the <a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">mountMedium</a><b></b> call. See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> for more detailed information about mounting a medium.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the storage controller the medium is attached to.</td></tr>
    <tr><td class="paramname">controllerPort</td><td>Port to query.</td></tr>
    <tr><td class="paramname">device</td><td>Device slot in the given port to query.</td></tr>
    <tr><td class="paramname">medium</td><td>Attached medium object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>No medium attached to given slot/bus. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a645de5a36a9fd0380d5651ec61013c54" name="a645de5a36a9fd0380d5651ec61013c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645de5a36a9fd0380d5651ec61013c54">&#9670;&#160;</a></span>getMediumAttachmentsOfController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getMediumAttachmentsOfController </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a>[]&#160;</td>
          <td class="paramname"><em>mediumAttachments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of medium attachments which are attached to the the controller with the given name. </p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>A storage controller with given name doesn't exist. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aa8a32585929a391a118c82778138df3a" name="aa8a32585929a391a118c82778138df3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a32585929a391a118c82778138df3a">&#9670;&#160;</a></span>getMediumAttachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getMediumAttachment </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a>&#160;</td>
          <td class="paramname"><em>attachment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a medium attachment which corresponds to the controller with the given name, on the given port and device slot. </p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>No attachment exists for the given controller/port/device combination. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a2640706ef6d61ac1d430199d162035ae" name="a2640706ef6d61ac1d430199d162035ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2640706ef6d61ac1d430199d162035ae">&#9670;&#160;</a></span>attachHostPCIDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::attachHostPCIDevice </td>
          <td>(</td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>hostAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>desiredGuestAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>tryToUnbind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches host PCI device with the given (host) PCI address to the PCI bus of the virtual machine. </p>
<p>Please note, that this operation is two phase, as real attachment will happen when VM will start, and most information will be delivered as <a class="el" href="interface_i_host_p_c_i_device_plug_event.html" title="Notification when host PCI device is plugged/unplugged.">IHostPCIDevicePlugEvent</a> on <a class="el" href="interface_i_virtual_box.html" title="The IVirtualBox interface represents the main interface exposed by the product that provides virtual ...">IVirtualBox</a> event source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostAddress</td><td>Address of the host PCI device.</td></tr>
    <tr><td class="paramname">desiredGuestAddress</td><td>Desired position of this device on guest PCI bus.</td></tr>
    <tr><td class="paramname">tryToUnbind</td><td>If VMM shall try to unbind existing drivers from the device before attaching it to the guest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine state is not stopped (PCI hotplug not yet implemented). </td></tr>
<tr>
<td>VBOX_E_PDM_ERROR</td><td>Virtual machine does not have a PCI controller allowing attachment of physical devices. </td></tr>
<tr>
<td>VBOX_E_NOT_SUPPORTED</td><td>Hardware or host OS doesn't allow PCI device passthrough. </td></tr>
</table>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_i_host_p_c_i_device_plug_event.html">IHostPCIDevicePlugEvent</a><b></b> </dd></dl>

</div>
</div>
<a id="a6b94280b4763b7522c4003b095a463d2" name="a6b94280b4763b7522c4003b095a463d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b94280b4763b7522c4003b095a463d2">&#9670;&#160;</a></span>detachHostPCIDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::detachHostPCIDevice </td>
          <td>(</td>
          <td class="paramtype">in long&#160;</td>
          <td class="paramname"><em>hostAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach host PCI device from the virtual machine. </p>
<p>Also HostPCIDevicePlugEvent on <a class="el" href="interface_i_virtual_box.html" title="The IVirtualBox interface represents the main interface exposed by the product that provides virtual ...">IVirtualBox</a> event source will be delivered. As currently we don't support hot device unplug, <a class="el" href="interface_i_host_p_c_i_device_plug_event.html" title="Notification when host PCI device is plugged/unplugged.">IHostPCIDevicePlugEvent</a> event is delivered immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostAddress</td><td>Address of the host PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine state is not stopped (PCI hotplug not yet implemented). </td></tr>
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>This host device is not attached to this machine. </td></tr>
<tr>
<td>VBOX_E_PDM_ERROR</td><td>Virtual machine does not have a PCI controller allowing attachment of physical devices. </td></tr>
<tr>
<td>VBOX_E_NOT_SUPPORTED</td><td>Hardware or host OS doesn't allow PCI device passthrough. </td></tr>
</table>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_i_host_p_c_i_device_plug_event.html">IHostPCIDevicePlugEvent</a><b></b> </dd></dl>

</div>
</div>
<a id="a0a508ff696684f587ae4a7db17bace62" name="a0a508ff696684f587ae4a7db17bace62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a508ff696684f587ae4a7db17bace62">&#9670;&#160;</a></span>getNetworkAdapter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getNetworkAdapter </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_network_adapter.html">INetworkAdapter</a>&#160;</td>
          <td class="paramname"><em>adapter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the network adapter associated with the given slot. </p>
<p>Slots are numbered sequentially, starting with zero. The total number of adapters per machine is defined by the <a class="el" href="interface_i_platform_properties.html#ac0492d9c0357bb91c18d9e2ea6222d66">IPlatformProperties::getMaxNetworkAdapters</a><b></b> property, so the maximum slot number is one less than that property's value.</p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>Invalid <em>slot</em> number. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="afc365a671090919d1d01cec078f4b170" name="afc365a671090919d1d01cec078f4b170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc365a671090919d1d01cec078f4b170">&#9670;&#160;</a></span>addStorageController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::addStorageController </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ab955ac5f95964be27366be7bbc8f3cf0">StorageBus</a>&#160;</td>
          <td class="paramname"><em>connectionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a>&#160;</td>
          <td class="paramname"><em>controller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new storage controller (SCSI, SAS or SATA controller) to the machine and returns it as an instance of <a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>. </p>
<p><em>name</em> identifies the controller for subsequent calls such as <a class="el" href="interface_i_machine.html#ab21595d46844b061ab54c4a79915b676">getStorageControllerByName</a><b></b>, <a class="el" href="interface_i_machine.html#a3768c3b8830806154fa9c5284b1cdb52">getStorageControllerByInstance</a><b></b>, <a class="el" href="interface_i_machine.html#af6cb6937da2196d9bc13d9670c6f6eaf">removeStorageController</a><b></b>, <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">attachDevice</a><b></b> or <a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">mountMedium</a><b></b>.</p>
<p>After the controller has been added, you can set its exact type by setting the <a class="el" href="interface_i_storage_controller.html#ae1bd486ff9df74163e79d63dae96bd8c">IStorageController::controllerType</a><b></b>.</p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_IN_USE</td><td>A storage controller with given name exists already. </td></tr>
<tr>
<td>E_INVALIDARG</td><td>Invalid <em>controllerType</em>. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ab21595d46844b061ab54c4a79915b676" name="ab21595d46844b061ab54c4a79915b676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21595d46844b061ab54c4a79915b676">&#9670;&#160;</a></span>getStorageControllerByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getStorageControllerByName </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a>&#160;</td>
          <td class="paramname"><em>storageController</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a storage controller with the given name. </p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>A storage controller with given name doesn't exist. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a3768c3b8830806154fa9c5284b1cdb52" name="a3768c3b8830806154fa9c5284b1cdb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3768c3b8830806154fa9c5284b1cdb52">&#9670;&#160;</a></span>getStorageControllerByInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getStorageControllerByInstance </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ab955ac5f95964be27366be7bbc8f3cf0">StorageBus</a>&#160;</td>
          <td class="paramname"><em>connectionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a>&#160;</td>
          <td class="paramname"><em>storageController</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a storage controller of a specific storage bus with the given instance number. </p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>A storage controller with given instance number doesn't exist. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="af6cb6937da2196d9bc13d9670c6f6eaf" name="af6cb6937da2196d9bc13d9670c6f6eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cb6937da2196d9bc13d9670c6f6eaf">&#9670;&#160;</a></span>removeStorageController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::removeStorageController </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a storage controller from the machine with all devices attached to it. </p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>A storage controller with given name doesn't exist. </td></tr>
<tr>
<td>VBOX_E_NOT_SUPPORTED</td><td>Medium format does not support storage deletion (only for implicitly created differencing media, should not happen). </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a5d4d1c7791274f8baaef6e341f029cd2" name="a5d4d1c7791274f8baaef6e341f029cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4d1c7791274f8baaef6e341f029cd2">&#9670;&#160;</a></span>setStorageControllerBootable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setStorageControllerBootable </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>bootable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bootable flag of the storage controller with the given name. </p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>A storage controller with given name doesn't exist. </td></tr>
<tr>
<td>VBOX_E_OBJECT_IN_USE</td><td>Another storage controller is marked as bootable already. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a33e995ab41fff5b44e5ac4ad343b68df" name="a33e995ab41fff5b44e5ac4ad343b68df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e995ab41fff5b44e5ac4ad343b68df">&#9670;&#160;</a></span>addUSBController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::addUSBController </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#aa23093dc281cfe164756f86b5ebf7b97">USBControllerType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_u_s_b_controller.html">IUSBController</a>&#160;</td>
          <td class="paramname"><em>controller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new USB controller to the machine and returns it as an instance of <a class="el" href="interface_i_u_s_b_controller.html">IUSBController</a><b></b>. </p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_IN_USE</td><td>A USB controller with given type exists already. </td></tr>
<tr>
<td>E_INVALIDARG</td><td>Invalid <em>controllerType</em>. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a1cb74d7d9bd334c2d60db04dd4d5c6bc" name="a1cb74d7d9bd334c2d60db04dd4d5c6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb74d7d9bd334c2d60db04dd4d5c6bc">&#9670;&#160;</a></span>removeUSBController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::removeUSBController </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a USB controller from the machine. </p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>A USB controller with given type doesn't exist. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ae3c46fa3925e49086137b951057a5b60" name="ae3c46fa3925e49086137b951057a5b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c46fa3925e49086137b951057a5b60">&#9670;&#160;</a></span>getUSBControllerByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getUSBControllerByName </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_u_s_b_controller.html">IUSBController</a>&#160;</td>
          <td class="paramname"><em>controller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a USB controller with the given type. </p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>A USB controller with given name doesn't exist. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aef4e5dc869b4972cfedeb13ac92b96f6" name="aef4e5dc869b4972cfedeb13ac92b96f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4e5dc869b4972cfedeb13ac92b96f6">&#9670;&#160;</a></span>getUSBControllerCountByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getUSBControllerCountByType </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#aa23093dc281cfe164756f86b5ebf7b97">USBControllerType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out unsigned long&#160;</td>
          <td class="paramname"><em>controllers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of USB controllers of the given type attached to the VM. </p>

</div>
</div>
<a id="a199fe95549cf07429f183302c59061c3" name="a199fe95549cf07429f183302c59061c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199fe95549cf07429f183302c59061c3">&#9670;&#160;</a></span>getSerialPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getSerialPort </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_serial_port.html">ISerialPort</a>&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the serial port associated with the given slot. </p>
<p>Slots are numbered sequentially, starting with zero. The total number of serial ports per machine is defined by the <a class="el" href="interface_i_platform_properties.html#a45ef6f80b8e7c5cb62c9e7d9558ad4f1">IPlatformProperties::serialPortCount</a><b></b> property, so the maximum slot number is one less than that property's value.</p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>Invalid <em>slot</em> number. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aafab6ae895f017b6fefc7cbdc753af02" name="aafab6ae895f017b6fefc7cbdc753af02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafab6ae895f017b6fefc7cbdc753af02">&#9670;&#160;</a></span>getParallelPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getParallelPort </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_parallel_port.html">IParallelPort</a>&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parallel port associated with the given slot. </p>
<p>Slots are numbered sequentially, starting with zero. The total number of parallel ports per machine is defined by the <a class="el" href="interface_i_platform_properties.html#aaaa86a579dad2108f46af2b886b6543e">IPlatformProperties::parallelPortCount</a><b></b> property, so the maximum slot number is one less than that property's value.</p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td>Invalid <em>slot</em> number. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a2a6bfbad64020e26408625a9229c04a2" name="a2a6bfbad64020e26408625a9229c04a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6bfbad64020e26408625a9229c04a2">&#9670;&#160;</a></span>getExtraDataKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getExtraDataKeys </td>
          <td>(</td>
          <td class="paramtype">[retval] out wstring[]&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array representing the machine-specific extra data keys which currently have values defined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Array of extra data keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83e5e2346988bfc8fa2f73b3b34a2823" name="a83e5e2346988bfc8fa2f73b3b34a2823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e5e2346988bfc8fa2f73b3b34a2823">&#9670;&#160;</a></span>getExtraData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getExtraData </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out wstring&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns associated machine-specific extra data. </p>
<p>If the requested data <em>key</em> does not exist, this function will succeed and return an empty string in the <em>value</em> argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Name of the data key to get.</td></tr>
    <tr><td class="paramname">value</td><td>Value of the requested data key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_FILE_ERROR</td><td>Settings file not accessible. </td></tr>
<tr>
<td>VBOX_E_XML_ERROR</td><td>Could not parse the settings file. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a79f89295518cbfcd582c9a63602f795a" name="a79f89295518cbfcd582c9a63602f795a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f89295518cbfcd582c9a63602f795a">&#9670;&#160;</a></span>setExtraData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setExtraData </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets associated machine-specific extra data. </p>
<p>If you pass <code>null</code> or an empty string as a key <em>value</em>, the given <em>key</em> will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Name of the data key to set.</td></tr>
    <tr><td class="paramname">value</td><td>Value to assign to the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_FILE_ERROR</td><td>Settings file not accessible. </td></tr>
<tr>
<td>VBOX_E_XML_ERROR</td><td>Could not parse the settings file. </td></tr>
<tr>
<td>E_INVALIDARG</td><td>Key contains invalid characters. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Key must contain printable (non-control) UTF-8 characters only.</dd>
<dd>
Before performing the actual data change, this method will ask all registered event listeners using the <a class="el" href="interface_i_extra_data_can_change_event.html">IExtraDataCanChangeEvent</a><b></b> notification for a permission. If one of the listeners refuses the new value, the change will not be performed.</dd>
<dd>
On success, the <a class="el" href="interface_i_extra_data_changed_event.html">IExtraDataChangedEvent</a><b></b> notification is called to inform all registered listeners about a successful data change.</dd>
<dd>
This method can be called outside the machine session and therefore it's a caller's responsibility to handle possible race conditions when several clients change the same key at the same time. </dd></dl>

</div>
</div>
<a id="a579aa5eb632fd4a0f85e53ed927ec9b2" name="a579aa5eb632fd4a0f85e53ed927ec9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579aa5eb632fd4a0f85e53ed927ec9b2">&#9670;&#160;</a></span>setSettingsFilePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setSettingsFilePath </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>settingsFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Currently, it is an error to change this property on any machine. </p>
<p>Later this will allow setting a new path for the settings file, with automatic relocation of all files (including snapshots and disk images) which are inside the base directory. This operation is only allowed when there are no pending unsaved settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settingsFilePath</td><td>New settings file path, will be used to determine the new location for the attached media if it is in the same directory or below as the original settings file.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_NOTIMPL</td><td>The operation is not implemented yet. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Setting this property to <code>null</code> or to an empty string is forbidden. When setting this property, the specified path must be absolute. The specified path may not exist, it will be created when necessary. </dd></dl>

</div>
</div>
<a id="a2eb47e1d878566569b26893cc12bd8e1" name="a2eb47e1d878566569b26893cc12bd8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb47e1d878566569b26893cc12bd8e1">&#9670;&#160;</a></span>saveSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::saveSettings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves any changes to machine settings made since the session has been opened or a new machine has been created, or since the last call to <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> or <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>. </p>
<p>For registered machines, new settings become visible to all other VirtualBox clients after successful invocation of this method.</p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_FILE_ERROR</td><td>Settings file not accessible. </td></tr>
<tr>
<td>VBOX_E_XML_ERROR</td><td>Could not parse the settings file. </td></tr>
<tr>
<td>E_ACCESSDENIED</td><td>Modification request refused. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The method sends <a class="el" href="interface_i_machine_data_changed_event.html">IMachineDataChangedEvent</a><b></b> notification event after the configuration has been successfully saved (only for registered machines).</dd>
<dd>
Calling this method is only valid on instances returned by <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b> and on new machines created by <a class="el" href="interface_i_virtual_box.html#a1b70a47863291ef63443df0e49a30265">IVirtualBox::createMachine</a><b></b> but not yet registered, or on unregistered machines after calling <a class="el" href="interface_i_machine.html#a939a4b0bf949b0347c9e9d2acf320d1b">IMachine::unregister</a><b></b>. </dd></dl>

</div>
</div>
<a id="a341ac035501a0c168ad9571bbe86eb02" name="a341ac035501a0c168ad9571bbe86eb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341ac035501a0c168ad9571bbe86eb02">&#9670;&#160;</a></span>discardSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::discardSettings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discards any changes to the machine settings made since the session has been opened or since the last call to <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> or <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>. </p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine is not mutable. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this method is only valid on instances returned by <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b> and on new machines created by <a class="el" href="interface_i_virtual_box.html#a1b70a47863291ef63443df0e49a30265">IVirtualBox::createMachine</a><b></b> or opened by <a class="el" href="interface_i_virtual_box.html#abed607b37d5c17bbd73e77b4778f409b">IVirtualBox::openMachine</a><b></b> but not yet registered, or on unregistered machines after calling <a class="el" href="interface_i_machine.html#a939a4b0bf949b0347c9e9d2acf320d1b">IMachine::unregister</a><b></b>. </dd></dl>

</div>
</div>
<a id="a939a4b0bf949b0347c9e9d2acf320d1b" name="a939a4b0bf949b0347c9e9d2acf320d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939a4b0bf949b0347c9e9d2acf320d1b">&#9670;&#160;</a></span>unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::unregister </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a0381acf2db95fe7b709d78553346ea1c">CleanupMode</a>&#160;</td>
          <td class="paramname"><em>cleanupMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_medium.html">IMedium</a>[]&#160;</td>
          <td class="paramname"><em>media</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a machine previously registered with <a class="el" href="interface_i_virtual_box.html#a7a67d2e6643990d72949c8d6c806ed35">IVirtualBox::registerMachine</a><b></b> and optionally do additional cleanup before the machine is unregistered. </p>
<p>This method does not delete any files. It only changes the machine configuration and the list of registered machines in the VirtualBox object. To delete the files which belonged to the machine, including the XML file of the machine itself, call <a class="el" href="interface_i_machine.html#a8645f1405cd6d834a3be005c8d533d68">deleteConfig</a><b></b>, optionally with the array of <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks, CD/DVD or floppy drives.">IMedium</a> objects which was returned from this method.</p>
<p>How thoroughly this method cleans up the machine configuration before unregistering the machine depends on the <em>cleanupMode</em> argument.</p>
<ul>
<li>
With "UnregisterOnly", the machine will only be unregistered, but no additional cleanup will be performed. The call will fail if the machine has any snapshots or any media attached (see <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b>). It is the responsibility of the caller to delete all such configuration in this mode. In this mode, the API behaves like the former <code>IVirtualBox::unregisterMachine()</code> API which it replaces.</li>
<li>
With "DetachAllReturnNone", the call will succeed even if the machine is in "Saved" state or if it has snapshots or media attached. All media attached to the current machine state or in snapshots will be detached. No medium objects will be returned; all of the machine's media will remain open.</li>
<li>
With "DetachAllReturnHardDisksOnly", the call will behave like with "DetachAllReturnNone", except that all the hard disk medium objects which were detached from the machine will be returned as an array. This allows for quickly passing them to the <a class="el" href="interface_i_machine.html#a8645f1405cd6d834a3be005c8d533d68">deleteConfig</a><b></b> API for closing and deletion.</li>
<li>
With "Full", the call will behave like with "DetachAllReturnHardDisksOnly", except that all media will be returned in the array, including removable media like DVDs and floppies. This might be useful if the user wants to inspect in detail which media were attached to the machine. Be careful when passing the media array to <a class="el" href="interface_i_machine.html#a8645f1405cd6d834a3be005c8d533d68">deleteConfig</a><b></b> in that case because users will typically want to preserve ISO and RAW image files.</li>
</ul>
<p>A typical implementation will use "DetachAllReturnHardDisksOnly" and then pass the resulting <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks, CD/DVD or floppy drives.">IMedium</a> array to <a class="el" href="interface_i_machine.html#a8645f1405cd6d834a3be005c8d533d68">deleteConfig</a><b></b>. This way, the machine is completely deleted with all its saved states and hard disk images, but images for removable drives (such as ISO and RAW files) will remain on disk.</p>
<p>This API does not verify whether the media files returned in the array are still attached to other machines (i.e. shared between several machines). If such a shared image is passed to <a class="el" href="interface_i_machine.html#a8645f1405cd6d834a3be005c8d533d68">deleteConfig</a><b></b> however, closing the image will fail there and the image will be silently skipped.</p>
<p>This API may, however, move media from this machine's media registry to other media registries (see <a class="el" href="interface_i_medium.html">IMedium</a><b></b> for details on media registries). For machines created with VirtualBox 4.0 or later, if media from this machine's media registry are also attached to another machine (shared attachments), each such medium will be moved to another machine's registry. This is because without this machine's media registry, the other machine cannot find its media any more and would become inaccessible.</p>
<p>This API implicitly calls <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> to save all current machine settings before unregistering it. It may also silently call <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> on other machines if media are moved to other machines' media registries.</p>
<p>After successful method invocation, the <a class="el" href="interface_i_machine_registered_event.html">IMachineRegisteredEvent</a><b></b> event is fired.</p>
<p>The call will fail if the machine is currently locked (see <a class="el" href="interface_i_session.html">ISession</a><b></b>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cleanupMode</td><td>How to clean up after the machine has been unregistered.</td></tr>
    <tr><td class="paramname">media</td><td>List of media detached from the machine, depending on the <em>cleanupMode</em> parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Machine is currently locked for a session. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the given machine is inaccessible (see <a class="el" href="interface_i_machine.html#a2b6c9cc91c11db18c5b6b870556355f2">accessible</a><b></b>), it will be unregistered and fully uninitialized right afterwards. As a result, the returned machine object will be unusable and an attempt to call <b>any</b> method will return the "Object not ready" error. </dd></dl>

</div>
</div>
<a id="a8645f1405cd6d834a3be005c8d533d68" name="a8645f1405cd6d834a3be005c8d533d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8645f1405cd6d834a3be005c8d533d68">&#9670;&#160;</a></span>deleteConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::deleteConfig </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_medium.html">IMedium</a>[]&#160;</td>
          <td class="paramname"><em>media</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the files associated with this machine from disk. </p>
<p>If medium objects are passed in with the <em>aMedia</em> argument, they are closed and, if closing was successful, their storage files are deleted as well. For convenience, this array of media files can be the same as the one returned from a previous <a class="el" href="interface_i_machine.html#a939a4b0bf949b0347c9e9d2acf320d1b">unregister</a><b></b> call.</p>
<p>This method must only be called on machines which are either write-locked (i.e. on instances returned by <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b>) or on unregistered machines (i.e. not yet registered machines created by <a class="el" href="interface_i_virtual_box.html#a1b70a47863291ef63443df0e49a30265">IVirtualBox::createMachine</a><b></b> or opened by <a class="el" href="interface_i_virtual_box.html#abed607b37d5c17bbd73e77b4778f409b">IVirtualBox::openMachine</a><b></b>, or after having called <a class="el" href="interface_i_machine.html#a939a4b0bf949b0347c9e9d2acf320d1b">unregister</a><b></b>).</p>
<p>The following files will be deleted by this method:</p>
<ul>
<li>
If <a class="el" href="interface_i_machine.html#a939a4b0bf949b0347c9e9d2acf320d1b">unregister</a><b></b> had been previously called with a <em>cleanupMode</em> argument other than "UnregisterOnly", this will delete all saved state files that the machine had in use; possibly one if the machine was in either the "Saved" or "AbortedSaved" state and one for each online snapshot that the machine had.</li>
<li>
On each medium object passed in the <em>aMedia</em> array, this will call <a class="el" href="interface_i_medium.html#a8e006ecc7b5bc8d9d8cb281b237a8e23">IMedium::close</a><b></b>. If that succeeds, this will attempt to delete the medium's storage on disk. Since the <a class="el" href="interface_i_medium.html#a8e006ecc7b5bc8d9d8cb281b237a8e23">IMedium::close</a><b></b> call will fail if the medium is still in use, e.g. because it is still attached to a second machine; in that case the storage will not be deleted.</li>
<li>
Finally, the machine's own XML file will be deleted.</li>
</ul>
<p>Since deleting large disk image files can be a time-consuming I/O operation, this method operates asynchronously and returns an <a class="el" href="interface_i_progress.html" title="The IProgress interface is used to track and control asynchronous tasks within VirtualBox.">IProgress</a> object to allow the caller to monitor the progress. There will be one sub-operation for each file that is being deleted (saved state or medium storage file).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">media</td><td>List of media to be closed and whose storage files will be deleted.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Machine is registered but not write-locked. </td></tr>
<tr>
<td>VBOX_E_IPRT_ERROR</td><td>Could not delete the settings file. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="interface_i_machine.html#a7fa04613f860573400ba570fcf80f3ef">settingsModified</a><b></b> will return <code>true</code> after this method successfully returns. </dd></dl>

</div>
</div>
<a id="a53a235b5dc96eda9bc10b80b139fbbd5" name="a53a235b5dc96eda9bc10b80b139fbbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a235b5dc96eda9bc10b80b139fbbd5">&#9670;&#160;</a></span>exportTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::exportTo </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_appliance.html">IAppliance</a>&#160;</td>
          <td class="paramname"><em>appliance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_virtual_system_description.html">IVirtualSystemDescription</a>&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports the machine to an OVF appliance. </p>
<p>See <a class="el" href="interface_i_appliance.html">IAppliance</a><b></b> for the steps required to export VirtualBox machines to OVF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">appliance</td><td>Appliance to export this machine to.</td></tr>
    <tr><td class="paramname">location</td><td>The target location.</td></tr>
    <tr><td class="paramname">description</td><td>VirtualSystemDescription object which is created for this machine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abce8554c37a221ab8d493bacc0dafff4" name="abce8554c37a221ab8d493bacc0dafff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce8554c37a221ab8d493bacc0dafff4">&#9670;&#160;</a></span>findSnapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::findSnapshot </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>nameOrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_snapshot.html">ISnapshot</a>&#160;</td>
          <td class="paramname"><em>snapshot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a snapshot of this machine with the given name or UUID. </p>
<p>Returns a snapshot of this machine with the given UUID. A <code>null</code> argument can be used to obtain the first snapshot taken on this machine. To traverse the whole tree of snapshots starting from the root, inspect the root snapshot's <a class="el" href="interface_i_snapshot.html#a7864167d1b7c440cc3bb49c1a8626354">ISnapshot::children</a><b></b> attribute and recurse over those children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nameOrId</td><td>What to search for. Name or UUID of the snapshot to find</td></tr>
    <tr><td class="paramname">snapshot</td><td>Snapshot object with the given name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>Virtual machine has no snapshots or snapshot not found. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a56d8797225812968b96f0663a02bd4ff" name="a56d8797225812968b96f0663a02bd4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d8797225812968b96f0663a02bd4ff">&#9670;&#160;</a></span>createSharedFolder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::createSharedFolder </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>hostPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>writable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>automount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>autoMountPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new permanent shared folder by associating the given logical name with the given host path, adds it to the collection of shared folders and starts sharing it. </p>
<p>Refer to the description of <a class="el" href="interface_i_shared_folder.html">ISharedFolder</a><b></b> to read more about logical names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Unique logical name of the shared folder.</td></tr>
    <tr><td class="paramname">hostPath</td><td>Full path to the shared folder in the host file system.</td></tr>
    <tr><td class="paramname">writable</td><td>Whether the share is writable or read-only.</td></tr>
    <tr><td class="paramname">automount</td><td>Whether the share gets automatically mounted by the guest or not.</td></tr>
    <tr><td class="paramname">autoMountPoint</td><td>Where the guest should automatically mount the folder, if possible. For Windows and OS/2 guests this should be a drive letter, while other guests it should be a absolute directory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_OBJECT_IN_USE</td><td>Shared folder already exists. </td></tr>
<tr>
<td>VBOX_E_FILE_ERROR</td><td>Shared folder <em>hostPath</em> not accessible. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a30e6a10490fde39a3e97e2ae1d1fa3ce" name="a30e6a10490fde39a3e97e2ae1d1fa3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e6a10490fde39a3e97e2ae1d1fa3ce">&#9670;&#160;</a></span>removeSharedFolder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::removeSharedFolder </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the permanent shared folder with the given name previously created by <a class="el" href="interface_i_machine.html#a56d8797225812968b96f0663a02bd4ff">createSharedFolder</a><b></b> from the collection of shared folders and stops sharing it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Logical name of the shared folder to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine is not mutable. </td></tr>
<tr>
<td>VBOX_E_OBJECT_NOT_FOUND</td><td>Shared folder <em>name</em> does not exist. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aebbda0c226bb18cd02f01e8492bbe3a1" name="aebbda0c226bb18cd02f01e8492bbe3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbda0c226bb18cd02f01e8492bbe3a1">&#9670;&#160;</a></span>canShowConsoleWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::canShowConsoleWindow </td>
          <td>(</td>
          <td class="paramtype">[retval] out boolean&#160;</td>
          <td class="paramname"><em>canShow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the VM console process can activate the console window and bring it to foreground on the desktop of the host PC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canShow</td><td><code>true</code> if the console window can be shown and <code>false</code> otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Machine session is not open. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method will fail if a session for this machine is not currently open. </dd></dl>

</div>
</div>
<a id="ada877c47a8efa8a62967f8cb0387bfbc" name="ada877c47a8efa8a62967f8cb0387bfbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada877c47a8efa8a62967f8cb0387bfbc">&#9670;&#160;</a></span>showConsoleWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::showConsoleWindow </td>
          <td>(</td>
          <td class="paramtype">[retval] out long long&#160;</td>
          <td class="paramname"><em>winId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activates the console window and brings it to foreground on the desktop of the host PC. </p>
<p>Many modern window managers on many platforms implement some sort of focus stealing prevention logic, so that it may be impossible to activate a window without the help of the currently active application. In this case, this method will return a non-zero identifier that represents the top-level window of the VM console process. The caller, if it represents a currently active process, is responsible to use this identifier (in a platform-dependent manner) to perform actual window activation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">winId</td><td>Platform-dependent identifier of the top-level VM console window, or zero if this method has performed all actions necessary to implement the <em>show window</em> semantics for the given platform and/or VirtualBox front-end.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Machine session is not open. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method will fail if a session for this machine is not currently open. </dd></dl>

</div>
</div>
<a id="a9f2fffade4b897eb659cc4602694676d" name="a9f2fffade4b897eb659cc4602694676d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2fffade4b897eb659cc4602694676d">&#9670;&#160;</a></span>getGuestProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getGuestProperty </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out long long&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an entry from the machine's guest property store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the property to read.</td></tr>
    <tr><td class="paramname">value</td><td>The value of the property. If the property does not exist then this will be empty.</td></tr>
    <tr><td class="paramname">timestamp</td><td>The time at which the property was last modified, as seen by the server process.</td></tr>
    <tr><td class="paramname">flags</td><td>Additional property parameters, passed as a comma-separated list of "name=value" type entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Machine session is not open. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a36a328440fca57459efcbeadb76c548b" name="a36a328440fca57459efcbeadb76c548b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a328440fca57459efcbeadb76c548b">&#9670;&#160;</a></span>getGuestPropertyValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getGuestPropertyValue </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out wstring&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a value from the machine's guest property store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The name of the property to read.</td></tr>
    <tr><td class="paramname">value</td><td>The value of the property. If the property does not exist then this will be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Machine session is not open. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a269df6613496c92f104269c15a68ad9a" name="a269df6613496c92f104269c15a68ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269df6613496c92f104269c15a68ad9a">&#9670;&#160;</a></span>getGuestPropertyTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getGuestPropertyTimestamp </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a property timestamp from the machine's guest property store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The name of the property to read.</td></tr>
    <tr><td class="paramname">value</td><td>The timestamp. If the property does not exist then this will be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Machine session is not open. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a526521a6479eeaf3067550417a7bb888" name="a526521a6479eeaf3067550417a7bb888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526521a6479eeaf3067550417a7bb888">&#9670;&#160;</a></span>setGuestProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setGuestProperty </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets, changes or deletes an entry in the machine's guest property store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The name of the property to set, change or delete.</td></tr>
    <tr><td class="paramname">value</td><td>The new value of the property to set, change or delete. If the property does not yet exist and value is non-empty, it will be created. If the value is <code>null</code> or empty, the property will be deleted if it exists.</td></tr>
    <tr><td class="paramname">flags</td><td>Additional property parameters, passed as a comma-separated list of "name=value" type entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_ACCESSDENIED</td><td>Property cannot be changed. </td></tr>
<tr>
<td>E_INVALIDARG</td><td>Invalid <em>flags</em>. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine is not mutable or session not open. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Cannot set transient property when machine not running. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a86db68f492c701d4fd323cf6aab633b9" name="a86db68f492c701d4fd323cf6aab633b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86db68f492c701d4fd323cf6aab633b9">&#9670;&#160;</a></span>setGuestPropertyValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setGuestPropertyValue </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or changes a value in the machine's guest property store. </p>
<p>The flags field will be left unchanged or created empty for a new property.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The name of the property to set or change.</td></tr>
    <tr><td class="paramname">value</td><td>The new value of the property to set or change. If the property does not yet exist and value is non-empty, it will be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_ACCESSDENIED</td><td>Property cannot be changed. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine is not mutable or session not open. </td></tr>
<tr>
<td>VBOX_E_INVALID_OBJECT_STATE</td><td>Cannot set transient property when machine not running. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a2b5bc248ab2a58bdab899dd0ab0b6b10" name="a2b5bc248ab2a58bdab899dd0ab0b6b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5bc248ab2a58bdab899dd0ab0b6b10">&#9670;&#160;</a></span>deleteGuestProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::deleteGuestProperty </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes an entry from the machine's guest property store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the property to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Machine session is not open. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a28c7ee7d951f5138e0e495fb2b1d572e" name="a28c7ee7d951f5138e0e495fb2b1d572e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c7ee7d951f5138e0e495fb2b1d572e">&#9670;&#160;</a></span>enumerateGuestProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::enumerateGuestProperties </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring[]&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring[]&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out long long[]&#160;</td>
          <td class="paramname"><em>timestamps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring[]&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of the guest properties matching a set of patterns along with their values, timestamps and flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patterns</td><td>The patterns to match the properties against, separated by '|' characters. If this is empty or <code>null</code>, all properties will match.</td></tr>
    <tr><td class="paramname">names</td><td>The names of the properties returned.</td></tr>
    <tr><td class="paramname">values</td><td>The values of the properties returned. The array entries match the corresponding entries in the <em>name</em> array.</td></tr>
    <tr><td class="paramname">timestamps</td><td>The timestamps of the properties returned. The array entries match the corresponding entries in the <em>name</em> array.</td></tr>
    <tr><td class="paramname">flags</td><td>The flags of the properties returned. The array entries match the corresponding entries in the <em>name</em> array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a854f70590d1680516cfd2e3ff0e2d7b6" name="a854f70590d1680516cfd2e3ff0e2d7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854f70590d1680516cfd2e3ff0e2d7b6">&#9670;&#160;</a></span>querySavedGuestScreenInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::querySavedGuestScreenInfo </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&#160;</td>
          <td class="paramname"><em>originX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&#160;</td>
          <td class="paramname"><em>originY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out boolean&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the guest dimensions from the saved state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">screenId</td><td>Saved guest screen to query info from.</td></tr>
    <tr><td class="paramname">originX</td><td>The X position of the guest monitor top left corner.</td></tr>
    <tr><td class="paramname">originY</td><td>The Y position of the guest monitor top left corner.</td></tr>
    <tr><td class="paramname">width</td><td>Guest width at the time of the saved state was taken.</td></tr>
    <tr><td class="paramname">height</td><td>Guest height at the time of the saved state was taken.</td></tr>
    <tr><td class="paramname">enabled</td><td>Whether the monitor is enabled in the guest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed902b9273e462a3479896cb7520b690" name="aed902b9273e462a3479896cb7520b690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed902b9273e462a3479896cb7520b690">&#9670;&#160;</a></span>readSavedThumbnailToArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::readSavedThumbnailToArray </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a23d1a7c7cf0f6da45ca389904e644d55">BitmapFormat</a>&#160;</td>
          <td class="paramname"><em>bitmapFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out octet[]&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thumbnail is retrieved to an array of bytes in the requested format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">screenId</td><td>Saved guest screen to read from.</td></tr>
    <tr><td class="paramname">bitmapFormat</td><td>The requested format.</td></tr>
    <tr><td class="paramname">width</td><td>Bitmap width.</td></tr>
    <tr><td class="paramname">height</td><td>Bitmap height.</td></tr>
    <tr><td class="paramname">data</td><td>Array with resulting bitmap data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16d60329c6bd61543f307fe1771a1f4c" name="a16d60329c6bd61543f307fe1771a1f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d60329c6bd61543f307fe1771a1f4c">&#9670;&#160;</a></span>querySavedScreenshotInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::querySavedScreenshotInfo </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="_virtual_box_8idl.html#a23d1a7c7cf0f6da45ca389904e644d55">BitmapFormat</a>[]&#160;</td>
          <td class="paramname"><em>bitmapFormats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns available formats and size of the screenshot from saved state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">screenId</td><td>Saved guest screen to query info from.</td></tr>
    <tr><td class="paramname">width</td><td>Image width.</td></tr>
    <tr><td class="paramname">height</td><td>Image height.</td></tr>
    <tr><td class="paramname">bitmapFormats</td><td>Formats supported by readSavedScreenshotToArray. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49f1daa5237065f1e430a367ceb9f77c" name="a49f1daa5237065f1e430a367ceb9f77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f1daa5237065f1e430a367ceb9f77c">&#9670;&#160;</a></span>readSavedScreenshotToArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::readSavedScreenshotToArray </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a23d1a7c7cf0f6da45ca389904e644d55">BitmapFormat</a>&#160;</td>
          <td class="paramname"><em>bitmapFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out octet[]&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Screenshot in requested format is retrieved to an array of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">screenId</td><td>Saved guest screen to read from.</td></tr>
    <tr><td class="paramname">bitmapFormat</td><td>The requested format.</td></tr>
    <tr><td class="paramname">width</td><td>Image width.</td></tr>
    <tr><td class="paramname">height</td><td>Image height.</td></tr>
    <tr><td class="paramname">data</td><td>Array with resulting image data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa561e166e64b11450803d0d981f2f093" name="aa561e166e64b11450803d0d981f2f093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa561e166e64b11450803d0d981f2f093">&#9670;&#160;</a></span>hotPlugCPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::hotPlugCPU </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plugs a CPU into the machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu</td><td>The CPU id to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b7f63a54fa7ef3250a0ad05528350dd" name="a4b7f63a54fa7ef3250a0ad05528350dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7f63a54fa7ef3250a0ad05528350dd">&#9670;&#160;</a></span>hotUnplugCPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::hotUnplugCPU </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a CPU from the machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu</td><td>The CPU id to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1f67f4ee8ce7b5c36d967ad4eb441fc" name="aa1f67f4ee8ce7b5c36d967ad4eb441fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f67f4ee8ce7b5c36d967ad4eb441fc">&#9670;&#160;</a></span>getCPUStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getCPUStatus </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out boolean&#160;</td>
          <td class="paramname"><em>attached</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current status of the given CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu</td><td>The CPU id to check for.</td></tr>
    <tr><td class="paramname">attached</td><td>Status of the CPU. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4108883f0ee02b97b062122a6bed96e0" name="a4108883f0ee02b97b062122a6bed96e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4108883f0ee02b97b062122a6bed96e0">&#9670;&#160;</a></span>getEffectiveParavirtProvider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getEffectiveParavirtProvider </td>
          <td>(</td>
          <td class="paramtype">[retval] out <a class="el" href="_virtual_box_8idl.html#ad4d63f64a610fd190118618ceac0f6ee">ParavirtProvider</a>&#160;</td>
          <td class="paramname"><em>paravirtProvider</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the effective paravirtualization provider for this VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paravirtProvider</td><td>The effective paravirtualization provider for this VM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4119197c357526503a23bd06b4b00357" name="a4119197c357526503a23bd06b4b00357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4119197c357526503a23bd06b4b00357">&#9670;&#160;</a></span>queryLogFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::queryLogFilename </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out wstring&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries for the VM log file name of an given index. </p>
<p>Returns an empty string if a log file with that index doesn't exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Which log file name to query. 0=current log file.</td></tr>
    <tr><td class="paramname">filename</td><td>On return the full path to the log file or an empty string on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a788bf7b15a62311430bfa72f4902d914" name="a788bf7b15a62311430bfa72f4902d914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788bf7b15a62311430bfa72f4902d914">&#9670;&#160;</a></span>readLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::readLog </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long long&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out octet[]&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the VM log file. </p>
<p>The chunk size is limited, so even if you ask for a big piece there might be less data returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Which log file to read. 0=current log file.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset in the log file.</td></tr>
    <tr><td class="paramname">size</td><td>Chunk size to read in the log file.</td></tr>
    <tr><td class="paramname">data</td><td>Data read from the log file. A data size of 0 means end of file if the requested chunk size was not 0. This is the unprocessed file data, i.e. the line ending style depends on the platform of the system the server is running on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8109a3cdf154e552fcf47b6198d464f0" name="a8109a3cdf154e552fcf47b6198d464f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8109a3cdf154e552fcf47b6198d464f0">&#9670;&#160;</a></span>cloneTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::cloneTo </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_machine.html">IMachine</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a16234ad9f11c851b50869d9718b664a2">CloneMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a15b096f772b66efdc6c998d70e575fc7">CloneOptions</a>[]&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a clone of this machine, either as a full clone (which means creating independent copies of the hard disk media, save states and so on), or as a linked clone (which uses its own differencing media, sharing the parent media with the source machine). </p>
<p>The target machine object must have been created previously with <a class="el" href="interface_i_virtual_box.html#a1b70a47863291ef63443df0e49a30265">IVirtualBox::createMachine</a><b></b>, and all the settings will be transferred except the VM name and the hardware UUID. You can set the VM name and the new hardware UUID when creating the target machine. The network MAC addresses are newly created for all enabled network adapters. You can change that behaviour with the options parameter. The operation is performed asynchronously, so the machine object will be not be usable until the <em>progress</em> object signals completion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Target machine object.</td></tr>
    <tr><td class="paramname">mode</td><td>Which states should be cloned.</td></tr>
    <tr><td class="paramname">options</td><td>Options for the cloning operation.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG</td><td><em>target</em> is <code>null</code>. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aa185a60ce7daba42f2fc716f7d09bac4" name="aa185a60ce7daba42f2fc716f7d09bac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa185a60ce7daba42f2fc716f7d09bac4">&#9670;&#160;</a></span>moveTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::moveTo </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>folder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move machine on to new place/folder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">folder</td><td>Target folder where machine is moved. May be the same folder where the VM already is located or the empty string, in which case the machine is kept in this location and the disk images and other files which are stored elsewhere are moved.</td></tr>
    <tr><td class="paramname">type</td><td>Type of moving. Possible values: basic - Only the files which belong solely to this machine are moved from the original machine's folder to a new folder.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78b13d68cea80df3bc65a4a77f8f3c6b" name="a78b13d68cea80df3bc65a4a77f8f3c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b13d68cea80df3bc65a4a77f8f3c6b">&#9670;&#160;</a></span>saveState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::saveState </td>
          <td>(</td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the current execution state of a running virtual machine and stops its execution. </p>
<p>After this operation completes, the machine will go to the Saved state. The next time it is powered up this state will be restored and the machine will continue its execution from the place where it was saved.</p>
<p>This operation differs from taking a snapshot to the effect that it doesn't create new differencing media. Also, once the machine is powered up from the state saved using this method, the saved state is deleted, so it will be impossible to return to this state later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine state neither Running nor Paused. </td></tr>
<tr>
<td>VBOX_E_FILE_ERROR</td><td>Failed to create directory for saved state file. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On success, this method implicitly calls <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> to save all current machine settings (including runtime changes to the DVD medium, etc.). Together with the impossibility to change any VM settings when it is in the Saved state, this guarantees adequate hardware configuration of the machine when it is restored from the saved state file.</dd>
<dd>
The machine must be in the Running or Paused state, otherwise the operation will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_i_machine.html#ab39f2d35139941c3c2eb1afcc1b5a319">takeSnapshot</a><b></b> </dd></dl>

</div>
</div>
<a id="a77849574e824b7911f2069f8733946ab" name="a77849574e824b7911f2069f8733946ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77849574e824b7911f2069f8733946ab">&#9670;&#160;</a></span>adoptSavedState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::adoptSavedState </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>savedStateFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associates the given saved state file to the virtual machine. </p>
<p>On success, the machine will go to the Saved state. The next time it is powered up it will be restored from the adopted saved state and continue execution from the place where the saved state file was created.</p>
<p>The specified saved state file path may be absolute or relative to the folder the VM normally saves the state to (usually, <a class="el" href="interface_i_machine.html#adfcf2b4359a54f318fa9f17ee521fd50">snapshotFolder</a><b></b>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">savedStateFile</td><td>Path to the saved state file to adopt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine state neither PoweredOff nor Aborted. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It's a caller's responsibility to make sure the given saved state file is compatible with the settings of this virtual machine that represent its virtual hardware (memory size, storage disk configuration etc.). If there is a mismatch, the behavior of the virtual machine is undefined. </dd></dl>

</div>
</div>
<a id="a6be3ff72c6dbe36c86d5a4fa5774bd12" name="a6be3ff72c6dbe36c86d5a4fa5774bd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be3ff72c6dbe36c86d5a4fa5774bd12">&#9670;&#160;</a></span>discardSavedState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::discardSavedState </td>
          <td>(</td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>fRemoveFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forcibly resets the machine to "Powered Off" state if it is currently in the "Saved" state previously created by <a class="el" href="interface_i_machine.html#a78b13d68cea80df3bc65a4a77f8f3c6b">saveState</a><b></b>) or in the "AbortedSaved" state. </p>
<p>The next time the machine is powered up a clean boot will occur.</p>
<p>If <em>fRemoveFile</em> is <code>true</code>, the file in the machine directory into which the machine state was saved is also deleted. If this is <code>false</code>, then the state can be recovered and later re-inserted into a machine using <a class="el" href="interface_i_machine.html#a77849574e824b7911f2069f8733946ab">adoptSavedState</a><b></b>. The location of the file can be found in the <a class="el" href="interface_i_machine.html#a6bf84094ff47ad0f8f2517ee513eed02">stateFilePath</a><b></b> attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fRemoveFile</td><td>Whether to also remove the saved state file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine not in either the Saved or AbortedSaved state. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation is equivalent to resetting or powering off the machine without doing a proper shutdown of the guest operating system; as with resetting a running phyiscal computer, it can can lead to data loss. </dd></dl>

</div>
</div>
<a id="ab39f2d35139941c3c2eb1afcc1b5a319" name="ab39f2d35139941c3c2eb1afcc1b5a319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39f2d35139941c3c2eb1afcc1b5a319">&#9670;&#160;</a></span>takeSnapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::takeSnapshot </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>pause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstringUUID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the current execution state and all settings of the machine and creates differencing images for all normal (non-independent) media. </p>
<p>See <a class="el" href="interface_i_snapshot.html">ISnapshot</a><b></b> for an introduction to snapshots.</p>
<p>This method can be called for a PoweredOff, Saved (see <a class="el" href="interface_i_machine.html#a78b13d68cea80df3bc65a4a77f8f3c6b">saveState</a><b></b>), AbortedSaved, Running or Paused virtual machine. When the machine is PoweredOff, an offline snapshot is created. When the machine is Running a live snapshot is created, and an online snapshot is created when Paused.</p>
<p>The taken snapshot is always based on the <a class="el" href="interface_i_machine.html#ac785dbe04eccc0793d949d6940202767">current snapshot</a><b></b> of the associated virtual machine and becomes a new current snapshot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Short name for the snapshot.</td></tr>
    <tr><td class="paramname">description</td><td>Optional description of the snapshot.</td></tr>
    <tr><td class="paramname">pause</td><td>Whether the VM should be paused while taking the snapshot. Only relevant when the VM is running, and distinguishes between online (<code>true</code>) and live (<code>false</code>) snapshots. When the VM is not running the result is always an offline snapshot.</td></tr>
    <tr><td class="paramname">id</td><td>UUID of the snapshot which will be created. Useful for follow-up operations after the snapshot has been created.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine currently changing state. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method implicitly calls <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> to save all current machine settings before taking an offline snapshot. </dd></dl>

</div>
</div>
<a id="a4d541f845c2744f78315d146cb86084c" name="a4d541f845c2744f78315d146cb86084c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d541f845c2744f78315d146cb86084c">&#9670;&#160;</a></span>deleteSnapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::deleteSnapshot </td>
          <td>(</td>
          <td class="paramtype">in wstringUUID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts deleting the specified snapshot asynchronously. </p>
<p>See <a class="el" href="interface_i_snapshot.html">ISnapshot</a><b></b> for an introduction to snapshots.</p>
<p>The execution state and settings of the associated machine stored in the snapshot will be deleted. The contents of all differencing media of this snapshot will be merged with the contents of their dependent child media to keep the medium chain valid (in other words, all changes represented by media being deleted will be propagated to their child medium). After that, this snapshot's differencing medium will be deleted. The parent of this snapshot will become a new parent for all its child snapshots.</p>
<p>If the deleted snapshot is the current one, its parent snapshot will become a new current snapshot. The current machine state is not directly affected in this case, except that currently attached differencing media based on media of the deleted snapshot will be also merged as described above.</p>
<p>If the deleted snapshot is the first or current snapshot, then the respective <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> attributes will be adjusted. Deleting the current snapshot will also implicitly call <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> to make all current machine settings permanent.</p>
<p>Deleting a snapshot has the following preconditions:</p>
<ul>
<li>
Child media of all normal media of the deleted snapshot must be accessible (see <a class="el" href="interface_i_medium.html#ac250d2252217354b21b272b9387c94d4">IMedium::state</a><b></b>) for this operation to succeed. If only one running VM refers to all images which participates in merging the operation can be performed while the VM is running. Otherwise all virtual machines whose media are directly or indirectly based on the media of deleted snapshot must be powered off. In any case, online snapshot deleting usually is slower than the same operation without any running VM.</li>
<li>
You cannot delete the snapshot if a medium attached to it has more than one child medium (differencing images) because otherwise merging would be impossible. This might be the case if there is more than one child snapshot or differencing images were created for other reason (e.g. implicitly because of multiple machine attachments).</li>
</ul>
<p>The virtual machine's <a class="el" href="interface_i_machine.html#a9653e9d996d60fc54e8bed22179d92b2">state</a><b></b> is changed to "DeletingSnapshot", "DeletingSnapshotOnline" or "DeletingSnapshotPaused" while this operation is in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>UUID of the snapshot to delete.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>The running virtual machine prevents deleting this snapshot. This happens only in very specific situations, usually snapshots can be deleted without trouble while a VM is running. The error message text explains the reason for the failure. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Merging medium contents can be very time and disk space consuming, if these media are big in size and have many children. However, if the snapshot being deleted is the last (head) snapshot on the branch, the operation will be rather quick. </dd></dl>

</div>
</div>
<a id="ab8d9aa9722f4edc65eba6344a3c06061" name="ab8d9aa9722f4edc65eba6344a3c06061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d9aa9722f4edc65eba6344a3c06061">&#9670;&#160;</a></span>deleteSnapshotAndAllChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::deleteSnapshotAndAllChildren </td>
          <td>(</td>
          <td class="paramtype">in wstringUUID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts deleting the specified snapshot and all its children asynchronously. </p>
<p>See <a class="el" href="interface_i_snapshot.html">ISnapshot</a><b></b> for an introduction to snapshots. The conditions and many details are the same as with <a class="el" href="interface_i_machine.html#a4d541f845c2744f78315d146cb86084c">deleteSnapshot</a><b></b>.</p>
<p>This operation is very fast if the snapshot subtree does not include the current state. It is still significantly faster than deleting the snapshots one by one if the current state is in the subtree and there are more than one snapshots from current state to the snapshot which marks the subtree, since it eliminates the incremental image merging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>UUID of the snapshot to delete, including all its children.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>The running virtual machine prevents deleting this snapshot. This happens only in very specific situations, usually snapshots can be deleted without trouble while a VM is running. The error message text explains the reason for the failure. </td></tr>
<tr>
<td>E_NOTIMPL</td><td>The method is not implemented yet. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API method is right now not implemented! </dd></dl>

</div>
</div>
<a id="a163ef21621c97c9b5acd8873e958732f" name="a163ef21621c97c9b5acd8873e958732f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163ef21621c97c9b5acd8873e958732f">&#9670;&#160;</a></span>deleteSnapshotRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::deleteSnapshotRange </td>
          <td>(</td>
          <td class="paramtype">in wstringUUID&#160;</td>
          <td class="paramname"><em>startId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstringUUID&#160;</td>
          <td class="paramname"><em>endId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts deleting the specified snapshot range. </p>
<p>This is limited to linear snapshot lists, which means there may not be any other child snapshots other than the direct sequence between the start and end snapshot. If the start and end snapshot point to the same snapshot this method is completely equivalent to <a class="el" href="interface_i_machine.html#a4d541f845c2744f78315d146cb86084c">deleteSnapshot</a><b></b>. See <a class="el" href="interface_i_snapshot.html">ISnapshot</a><b></b> for an introduction to snapshots. The conditions and many details are the same as with <a class="el" href="interface_i_machine.html#a4d541f845c2744f78315d146cb86084c">deleteSnapshot</a><b></b>.</p>
<p>This operation is generally faster than deleting snapshots one by one and often also needs less extra disk space before freeing up disk space by deleting the removed disk images corresponding to the snapshot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startId</td><td>UUID of the first snapshot to delete.</td></tr>
    <tr><td class="paramname">endId</td><td>UUID of the last snapshot to delete.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>The running virtual machine prevents deleting this snapshot. This happens only in very specific situations, usually snapshots can be deleted without trouble while a VM is running. The error message text explains the reason for the failure. </td></tr>
<tr>
<td>E_NOTIMPL</td><td>The method is not implemented yet. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API method is right now not implemented! </dd></dl>

</div>
</div>
<a id="a5b696740ceccb14750718e2648d6928c" name="a5b696740ceccb14750718e2648d6928c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b696740ceccb14750718e2648d6928c">&#9670;&#160;</a></span>restoreSnapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::restoreSnapshot </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_snapshot.html">ISnapshot</a>&#160;</td>
          <td class="paramname"><em>snapshot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts resetting the machine's current state to the state contained in the given snapshot, asynchronously. </p>
<p>All current settings of the machine will be reset and changes stored in differencing media will be lost. See <a class="el" href="interface_i_snapshot.html">ISnapshot</a><b></b> for an introduction to snapshots.</p>
<p>After this operation is successfully completed, new empty differencing media are created for all normal media of the machine.</p>
<p>If the given snapshot is an online snapshot, the machine will go to the <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9ebac8fa7577db141baf9cc06279665f122b">Saved</a><b></b> state, so that the next time it is powered on, the execution state will be restored from the state of the snapshot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snapshot</td><td>The snapshot to restore the VM state from.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>Virtual machine is running. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The machine must not be running, otherwise the operation will fail.</dd>
<dd>
If the machine is in the <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9ebac8fa7577db141baf9cc06279665f122b">Saved</a><b></b> state prior to this operation, the saved state file will be implicitly deleted (as if <a class="el" href="interface_i_machine.html#a6be3ff72c6dbe36c86d5a4fa5774bd12">IMachine::discardSavedState</a><b></b> were called). </dd></dl>

</div>
</div>
<a id="a8708b1fd0f88ad7243a8a68bc5f44fe6" name="a8708b1fd0f88ad7243a8a68bc5f44fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8708b1fd0f88ad7243a8a68bc5f44fe6">&#9670;&#160;</a></span>applyDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::applyDefaults </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the defaults for the configured guest OS type. </p>
<p>This is primarily for getting sane settings straight after creating a new VM, but it can also be applied later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Additional flags, to be defined later.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_FAIL</td><td>General error. </td></tr>
<tr>
<td>VBOX_E_INVALID_VM_STATE</td><td>The machine is in invalid state. </td></tr>
<tr>
<td>VBOX_E_OBJECT_IN_USE</td><td>Some of the applied objects already exist. The method has been called to already configured machine. </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily a shortcut, centralizing the tedious job of getting the recommended settings and translating them into settings updates. The settings are made at the end of the call, but not saved. </dd></dl>

</div>
</div>
<a id="afe4287a2fe395fee9ec6ab344868dc8b" name="afe4287a2fe395fee9ec6ab344868dc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4287a2fe395fee9ec6ab344868dc8b">&#9670;&#160;</a></span>changeEncryption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::changeEncryption </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>currentPassword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>cipher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>newPassword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>newPasswordId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts encryption of this VM. </p>
<p>This means that the stored data of the VM is encrypted.</p>
<p>Please note that the results can be either returned straight away, or later as the result of the background operation via the object returned via the <em>progress</em> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentPassword</td><td>The current password the VM is protected with. Use an empty string to indicate that the VM isn't encrypted.</td></tr>
    <tr><td class="paramname">cipher</td><td>The cipher to use for encryption. An empty string indicates no encryption for the result.</td></tr>
    <tr><td class="paramname">newPassword</td><td>The new password the VM should be protected with. An empty password and password ID will result in the VM being encrypted with the current password.</td></tr>
    <tr><td class="paramname">newPasswordId</td><td>The ID of the new password when unlocking the VM.</td></tr>
    <tr><td class="paramname">force</td><td>Force reencryption of the data if just password is changed. Otherwise, if data already encrypted and cipher doesn't changed only the password is changed.</td></tr>
    <tr><td class="paramname">progress</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_NOT_SUPPORTED</td><td>Encryption is not supported for various reasons e.g. unsupported cipher. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a86a50259750dc8d030ce9465795d75e9" name="a86a50259750dc8d030ce9465795d75e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a50259750dc8d030ce9465795d75e9">&#9670;&#160;</a></span>getEncryptionSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getEncryptionSettings </td>
          <td>(</td>
          <td class="paramtype">out wstring&#160;</td>
          <td class="paramname"><em>cipher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring&#160;</td>
          <td class="paramname"><em>passwordId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the encryption settings for this VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td>The cipher used for encryption.</td></tr>
    <tr><td class="paramname">passwordId</td><td>The ID of the password when unlocking the VM.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_NOT_SUPPORTED</td><td>Encryption is not configured for this VM. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a8aad7a28412c13046bc78a14a4d522be" name="a8aad7a28412c13046bc78a14a4d522be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aad7a28412c13046bc78a14a4d522be">&#9670;&#160;</a></span>checkEncryptionPassword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::checkEncryptionPassword </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the supplied password is correct for the VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>The password to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_NOT_SUPPORTED</td><td>Encryption is not configured for this VM. </td></tr>
<tr>
<td>VBOX_E_PASSWORD_INCORRECT</td><td>The given password is incorrect. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a2987389c2cb0041edd49ae80d5b5e3ff" name="a2987389c2cb0041edd49ae80d5b5e3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2987389c2cb0041edd49ae80d5b5e3ff">&#9670;&#160;</a></span>addEncryptionPassword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::addEncryptionPassword </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>password</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a password used for encryption. </p>
<p>Updates the accesibility state if password used the VM encryption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier used for the password. Must match the identifier used when the encrypted VM was created.</td></tr>
    <tr><td class="paramname">password</td><td>The password.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_PASSWORD_INCORRECT</td><td>The password provided wasn't correct for the VM using the provided ID. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a6851d6656d1dae72611051a223f1fd76" name="a6851d6656d1dae72611051a223f1fd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6851d6656d1dae72611051a223f1fd76">&#9670;&#160;</a></span>addEncryptionPasswords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::addEncryptionPasswords </td>
          <td>(</td>
          <td class="paramtype">in wstring[]&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring[]&#160;</td>
          <td class="paramname"><em>passwords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds passwords used for encryption. </p>
<p>Updates the accesibility state if the list contains password used the VM encryption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ids</td><td>List of identifiers for the passwords. Must match the identifier used when the encrypted VM was created.</td></tr>
    <tr><td class="paramname">passwords</td><td>List of passwords.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>VBOX_E_PASSWORD_INCORRECT</td><td>The password provided wasn't correct for the VM using the provided ID. </td></tr>
<tr>
<td>E_INVALIDARG</td><td>Id and passwords arrays have different size. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a6e3c71a0cf25fb4a0c881d0811a1bc74" name="a6e3c71a0cf25fb4a0c881d0811a1bc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3c71a0cf25fb4a0c881d0811a1bc74">&#9670;&#160;</a></span>removeEncryptionPassword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::removeEncryptionPassword </td>
          <td>(</td>
          <td class="paramtype">in wstring&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a password used for the VM encryption/decryption. </p>
<p>The password can be removed only if the VM is powered off. Removing the password causes the VM goes to the inaccessible state and the password must be provided again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier used for the password. Must match the identifier used when the encrypted VM was created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If machine becomes inaccessible all passwords are purged. One has to add required passwords again using either <a class="el" href="interface_i_machine.html#a2987389c2cb0041edd49ae80d5b5e3ff">IMachine::addEncryptionPassword</a><b></b> or <a class="el" href="interface_i_machine.html#a6851d6656d1dae72611051a223f1fd76">IMachine::addEncryptionPasswords</a><b></b> methods. </dd></dl>

</div>
</div>
<a id="ad36522d66247ff7eee6131d43d11367f" name="ad36522d66247ff7eee6131d43d11367f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36522d66247ff7eee6131d43d11367f">&#9670;&#160;</a></span>clearAllEncryptionPasswords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::clearAllEncryptionPasswords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all provided VM passwords. </p>
<p>The passwords can be removed only if the VM is powered off. Removing the passwords causes the VM goes to the inaccessible state and the password must be provided again. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a06bb12649ae1d59be7dcf982d7a55817" name="a06bb12649ae1d59be7dcf982d7a55817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bb12649ae1d59be7dcf982d7a55817">&#9670;&#160;</a></span>parent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_virtual_box.html">IVirtualBox</a> IMachine::parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associated parent object. </p>

</div>
</div>
<a id="aaffa156e95de8db401aea3f1f95b2e0c" name="aaffa156e95de8db401aea3f1f95b2e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffa156e95de8db401aea3f1f95b2e0c">&#9670;&#160;</a></span>icon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute octet [] IMachine::icon</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overridden VM Icon details. </p>

</div>
</div>
<a id="a2b6c9cc91c11db18c5b6b870556355f2" name="a2b6c9cc91c11db18c5b6b870556355f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6c9cc91c11db18c5b6b870556355f2">&#9670;&#160;</a></span>accessible</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean IMachine::accessible</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this virtual machine is currently accessible or not. </p>
<p>A machine is always deemed accessible unless it is registered <em>and</em> its settings file cannot be read or parsed (either because the file itself is unavailable or has invalid XML contents).</p>
<p>Every time this property is read, the accessibility state of this machine is re-evaluated. If the returned value is <code>false</code>, the <a class="el" href="interface_i_machine.html#a81cdf161d5d9f8e3e1491802768e533a">accessError</a><b></b> property may be used to get the detailed error information describing the reason of inaccessibility, including XML error messages.</p>
<p>When the machine is inaccessible, only the following properties can be used on it:</p>
<ul>
<li>
<a class="el" href="interface_i_machine.html#a06bb12649ae1d59be7dcf982d7a55817">parent</a><b></b></li>
<li>
<a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a><b></b></li>
<li>
<a class="el" href="interface_i_machine.html#a7e7b7939c050afa7475e249e06961e75">settingsFilePath</a><b></b></li>
<li>
<a class="el" href="interface_i_machine.html#a2b6c9cc91c11db18c5b6b870556355f2">accessible</a><b></b></li>
<li>
<a class="el" href="interface_i_machine.html#a81cdf161d5d9f8e3e1491802768e533a">accessError</a><b></b></li>
</ul>
<p>An attempt to access any other property or method will return an error.</p>
<p>The only possible action you can perform on an inaccessible machine is to unregister it using the <a class="el" href="interface_i_machine.html#a939a4b0bf949b0347c9e9d2acf320d1b">IMachine::unregister</a><b></b> call (or, to check for the accessibility state once more by querying this property).</p>
<dl class="section note"><dt>Note</dt><dd>In the current implementation, once this property returns <code>true</code>, the machine will never become inaccessible later, even if its settings file cannot be successfully read/written any more (at least, until the VirtualBox server is restarted). This limitation may be removed in future releases. </dd></dl>

</div>
</div>
<a id="a81cdf161d5d9f8e3e1491802768e533a" name="a81cdf161d5d9f8e3e1491802768e533a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cdf161d5d9f8e3e1491802768e533a">&#9670;&#160;</a></span>accessError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_virtual_box_error_info.html">IVirtualBoxErrorInfo</a> IMachine::accessError</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error information describing the reason of machine inaccessibility. </p>
<p>Reading this property is only valid after the last call to <a class="el" href="interface_i_machine.html#a2b6c9cc91c11db18c5b6b870556355f2">accessible</a><b></b> returned <code>false</code> (i.e. the machine is currently inaccessible). Otherwise, a <code>null</code> <a class="el" href="interface_i_virtual_box_error_info.html" title="The IVirtualBoxErrorInfo interface represents extended error information.">IVirtualBoxErrorInfo</a> object will be returned. </p>

</div>
</div>
<a id="a0f8041e0562be7a0b32be686384285f5" name="a0f8041e0562be7a0b32be686384285f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8041e0562be7a0b32be686384285f5">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the virtual machine. </p>
<p>Besides being used for human-readable identification purposes everywhere in VirtualBox, the virtual machine name is also used as a name of the machine's settings file and as a name of the subdirectory this settings file resides in. Thus, every time you change the value of this property, the settings file will be renamed once you call <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> to confirm the change. The containing subdirectory will be also renamed, but only if it has exactly the same name as the settings file itself prior to changing this property (for backward compatibility with previous API releases). The above implies the following limitations:</p>
<ul>
<li>
The machine name cannot be empty.</li>
<li>
The machine name can contain only characters that are valid file name characters according to the rules of the file system used to store VirtualBox configuration.</li>
<li>
You cannot have two or more machines with the same name if they use the same subdirectory for storing the machine settings files.</li>
<li>
You cannot change the name of the machine if it is running, or if any file in the directory containing the settings file is being used by another running machine or by any other process in the host operating system at a time when <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> is called. </li>
</ul>
<p>If any of the above limitations are hit, <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> will return an appropriate error message explaining the exact reason and the changes you made to this machine will not be saved.</p>
<p>Starting with VirtualBox 4.0, a ".vbox" extension of the settings file is recommended, but not enforced. (Previous versions always used a generic ".xml" extension.) </p>

</div>
</div>
<a id="af19c3adad1315ceb9bdac881e545e602" name="af19c3adad1315ceb9bdac881e545e602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19c3adad1315ceb9bdac881e545e602">&#9670;&#160;</a></span>description</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::description</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Description of the virtual machine. </p>
<p>The description attribute can contain any text and is typically used to describe the hardware and software configuration of the virtual machine in detail (i.e. network settings, versions of the installed software and so on). </p>

</div>
</div>
<a id="a8c2872f28654d4cee4e8029bf6eaec60" name="a8c2872f28654d4cee4e8029bf6eaec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2872f28654d4cee4e8029bf6eaec60">&#9670;&#160;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstringUUID IMachine::id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UUID of the virtual machine. </p>

</div>
</div>
<a id="a27536e99a6b64ac628a9098037ab5d7c" name="a27536e99a6b64ac628a9098037ab5d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27536e99a6b64ac628a9098037ab5d7c">&#9670;&#160;</a></span>groups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring [] IMachine::groups</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of machine group names of which this machine is a member. </p>
<p><code>""</code> and <code>"/"</code> are synonyms for the toplevel group. Each group is only listed once, however they are listed in no particular order and there is no guarantee that there are no gaps in the group hierarchy (i.e. <code>"/group"</code>, <code>"/group/subgroup/subsubgroup"</code> is a valid result). </p>

</div>
</div>
<a id="a8b78acadfe037c9153080fb055f46a7d" name="a8b78acadfe037c9153080fb055f46a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b78acadfe037c9153080fb055f46a7d">&#9670;&#160;</a></span>OSTypeId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::OSTypeId</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined identifier of the Guest OS type. </p>
<p>You may use <a class="el" href="interface_i_virtual_box.html#ae5b3d4b5b0869185c42ba8fb1d64a9cf">IVirtualBox::getGuestOSType</a><b></b> to obtain an <a class="el" href="interface_i_guest_o_s_type.html" title="Specifies a guest OS type and its recommendations.">IGuestOSType</a> object representing details about the given Guest OS type. All Guest OS types are considered valid, even those which are not known to <a class="el" href="interface_i_virtual_box.html#ae5b3d4b5b0869185c42ba8fb1d64a9cf">IVirtualBox::getGuestOSType</a><b></b>.</p>
<dl class="section note"><dt>Note</dt><dd>This value may differ from the value returned by <a class="el" href="interface_i_guest.html#a1836d4706baed01b5de022ac2ca25ab6">IGuest::OSTypeId</a><b></b> if Guest Additions are installed to the guest OS. </dd></dl>

</div>
</div>
<a id="a40e9ec512ab94e9878a1f848c51c8832" name="a40e9ec512ab94e9878a1f848c51c8832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e9ec512ab94e9878a1f848c51c8832">&#9670;&#160;</a></span>hardwareVersion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::hardwareVersion</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hardware version identifier. </p>
<p>Internal use only for now. </p>

</div>
</div>
<a id="ab2573dd9ec7e316b4c3115e84db9cf83" name="ab2573dd9ec7e316b4c3115e84db9cf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2573dd9ec7e316b4c3115e84db9cf83">&#9670;&#160;</a></span>hardwareUUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstringUUID IMachine::hardwareUUID</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The UUID presented to the guest via memory tables, hardware and guest properties. </p>
<p>For most VMs this is the same as the <em>id</em>, but for VMs which have been cloned or teleported it may be the same as the source VM. The latter is because the guest shouldn't notice that it was cloned or teleported. </p>

</div>
</div>
<a id="a78fd87584b8d5e02ccdf061c12e8e299" name="a78fd87584b8d5e02ccdf061c12e8e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fd87584b8d5e02ccdf061c12e8e299">&#9670;&#160;</a></span>CPUCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long IMachine::CPUCount</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of virtual CPUs in the VM. </p>

</div>
</div>
<a id="a466c25d9049510f39c71f7bd75bad63b" name="a466c25d9049510f39c71f7bd75bad63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466c25d9049510f39c71f7bd75bad63b">&#9670;&#160;</a></span>CPUHotPlugEnabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean IMachine::CPUHotPlugEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This setting determines whether VirtualBox allows CPU hotplugging for this machine. </p>

</div>
</div>
<a id="a47753f3eaff825b684018a2f88be95f6" name="a47753f3eaff825b684018a2f88be95f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47753f3eaff825b684018a2f88be95f6">&#9670;&#160;</a></span>CPUExecutionCap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long IMachine::CPUExecutionCap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Means to limit the number of CPU cycles a guest can use. </p>
<p>The unit is percentage of host CPU cycles per second. The valid range is 1 - 100. 100 (the default) implies no limit. </p>

</div>
</div>
<a id="a404c453a9d1d07b183798f1b1835b95a" name="a404c453a9d1d07b183798f1b1835b95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404c453a9d1d07b183798f1b1835b95a">&#9670;&#160;</a></span>CPUIDPortabilityLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long IMachine::CPUIDPortabilityLevel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual CPUID portability level. </p>
<p>The higher the number the fewer vendor-specific or recent CPU features are reported to the guest (via the CPUID instruction). The default level of zero (0) means that all virtualized features supported by the host are passed through to the guest. While the value of three (3) is currently the level suppressing the most features.</p>
<p>Exactly which of the CPUID features are left out by the VMM at which level is subject to change with each major version. </p>

</div>
</div>
<a id="a5bb5f057419fdc8505882ed5be4d6876" name="a5bb5f057419fdc8505882ed5be4d6876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb5f057419fdc8505882ed5be4d6876">&#9670;&#160;</a></span>memorySize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long IMachine::memorySize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System memory size in megabytes. </p>

</div>
</div>
<a id="af8340bf65bbf1a384b7902cfe65a6dd5" name="af8340bf65bbf1a384b7902cfe65a6dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8340bf65bbf1a384b7902cfe65a6dd5">&#9670;&#160;</a></span>memoryBalloonSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long IMachine::memoryBalloonSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory balloon size in megabytes. </p>

</div>
</div>
<a id="a29c0171d96c683d579974f4a508a7cf0" name="a29c0171d96c683d579974f4a508a7cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c0171d96c683d579974f4a508a7cf0">&#9670;&#160;</a></span>pageFusionEnabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean IMachine::pageFusionEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This setting determines whether VirtualBox allows page fusion for this machine (64-bit hosts only). </p>

</div>
</div>
<a id="aabba6fd260612821bb75b86b12292f0c" name="aabba6fd260612821bb75b86b12292f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabba6fd260612821bb75b86b12292f0c">&#9670;&#160;</a></span>graphicsAdapter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_graphics_adapter.html">IGraphicsAdapter</a> IMachine::graphicsAdapter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Graphics adapter object. </p>

</div>
</div>
<a id="a774e1dc666b5f28a0ba43c1ed0a8bdbf" name="a774e1dc666b5f28a0ba43c1ed0a8bdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774e1dc666b5f28a0ba43c1ed0a8bdbf">&#9670;&#160;</a></span>platform</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_platform.html">IPlatform</a> IMachine::platform</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associated platform object. </p>

</div>
</div>
<a id="aca6885010714dd25ffbf00b79c0144c9" name="aca6885010714dd25ffbf00b79c0144c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6885010714dd25ffbf00b79c0144c9">&#9670;&#160;</a></span>firmwareSettings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_firmware_settings.html">IFirmwareSettings</a> IMachine::firmwareSettings</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Object containing all firmware settings. </p>

</div>
</div>
<a id="a235de4969e89db6d7d84c6f8d6bd4353" name="a235de4969e89db6d7d84c6f8d6bd4353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235de4969e89db6d7d84c6f8d6bd4353">&#9670;&#160;</a></span>trustedPlatformModule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_trusted_platform_module.html">ITrustedPlatformModule</a> IMachine::trustedPlatformModule</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Object containing all TPM settings. </p>

</div>
</div>
<a id="af804d99f06ba056a08152eec3f686978" name="af804d99f06ba056a08152eec3f686978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af804d99f06ba056a08152eec3f686978">&#9670;&#160;</a></span>nonVolatileStore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_nvram_store.html">INvramStore</a> IMachine::nonVolatileStore</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Object to manipulate data in the non volatile storage file. </p>

</div>
</div>
<a id="a724d49f862f89708a37d0bdcc6d49be1" name="a724d49f862f89708a37d0bdcc6d49be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724d49f862f89708a37d0bdcc6d49be1">&#9670;&#160;</a></span>recordingSettings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_recording_settings.html">IRecordingSettings</a> IMachine::recordingSettings</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Object containing all recording settings. </p>

</div>
</div>
<a id="a169cccf5417aa6c90b4515f45b919d2e" name="a169cccf5417aa6c90b4515f45b919d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169cccf5417aa6c90b4515f45b919d2e">&#9670;&#160;</a></span>pointingHIDType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#ae904ea9e2892b3cb117b076fdf4c8897">PointingHIDType</a> IMachine::pointingHIDType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of pointing HID (such as mouse or tablet) used in this VM. </p>
<p>The default is typically "PS2Mouse" but can vary depending on the requirements of the guest operating system. </p>

</div>
</div>
<a id="a837c6f223122e587ff00027346a9f148" name="a837c6f223122e587ff00027346a9f148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837c6f223122e587ff00027346a9f148">&#9670;&#160;</a></span>keyboardHIDType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#af8b91ad2ad35847326c7d9d4c9587142">KeyboardHIDType</a> IMachine::keyboardHIDType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of keyboard HID used in this VM. </p>
<p>The default is typically "PS2Keyboard" but can vary depending on the requirements of the guest operating system. </p>

</div>
</div>
<a id="adfcf2b4359a54f318fa9f17ee521fd50" name="adfcf2b4359a54f318fa9f17ee521fd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcf2b4359a54f318fa9f17ee521fd50">&#9670;&#160;</a></span>snapshotFolder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::snapshotFolder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full path to the directory used to store snapshot data (differencing media and saved state files) of this machine. </p>
<p>The initial value of this property is <code>&lt;</code><a class="el" href="interface_i_machine.html#a7e7b7939c050afa7475e249e06961e75">path_to_settings_file</a><b></b><code>&gt;/&lt;</code><a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">machine_uuid</a><b></b><code>&gt;</code>.</p>
<p>Currently, it is an error to try to change this property on a machine that has snapshots (because this would require to move possibly large files to a different location). A separate method will be available for this purpose later.</p>
<dl class="section note"><dt>Note</dt><dd>Setting this property to <code>null</code> or to an empty string will restore the initial value.</dd>
<dd>
When setting this property, the specified path can be absolute (full path) or relative to the directory where the <a class="el" href="interface_i_machine.html#a7e7b7939c050afa7475e249e06961e75">machine settings file</a><b></b> is located. When reading this property, a full path is always returned.</dd>
<dd>
The specified path may not exist, it will be created when necessary. </dd></dl>

</div>
</div>
<a id="a74fe661f18e88069711241ca227c1708" name="a74fe661f18e88069711241ca227c1708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fe661f18e88069711241ca227c1708">&#9670;&#160;</a></span>VRDEServer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_v_r_d_e_server.html">IVRDEServer</a> IMachine::VRDEServer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VirtualBox Remote Desktop Extension (VRDE) server object. </p>

</div>
</div>
<a id="a31970f365eecc56cbf754eb0b1cf51a5" name="a31970f365eecc56cbf754eb0b1cf51a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31970f365eecc56cbf754eb0b1cf51a5">&#9670;&#160;</a></span>emulatedUSBCardReaderEnabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean IMachine::emulatedUSBCardReaderEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef972b7f8785c3a3f98a592a246ca4b4" name="aef972b7f8785c3a3f98a592a246ca4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef972b7f8785c3a3f98a592a246ca4b4">&#9670;&#160;</a></span>mediumAttachments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a> [] IMachine::mediumAttachments</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of media attached to this machine. </p>

</div>
</div>
<a id="ab2be494c024c890a7c5cd44b33a793c7" name="ab2be494c024c890a7c5cd44b33a793c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2be494c024c890a7c5cd44b33a793c7">&#9670;&#160;</a></span>USBControllers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_u_s_b_controller.html">IUSBController</a> [] IMachine::USBControllers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of USB controllers attached to this machine. </p>
<dl class="section note"><dt>Note</dt><dd>If USB functionality is not available in the given edition of VirtualBox, this method will set the result code to <code>E_NOTIMPL</code>. </dd></dl>

</div>
</div>
<a id="add060f5c12759baa796731f92e00655d" name="add060f5c12759baa796731f92e00655d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add060f5c12759baa796731f92e00655d">&#9670;&#160;</a></span>USBDeviceFilters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_u_s_b_device_filters.html">IUSBDeviceFilters</a> IMachine::USBDeviceFilters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associated USB device filters object. </p>
<dl class="section note"><dt>Note</dt><dd>If USB functionality is not available in the given edition of VirtualBox, this method will set the result code to <code>E_NOTIMPL</code>. </dd></dl>

</div>
</div>
<a id="adc58dbaf07bbb3eef30dc557de8ec00b" name="adc58dbaf07bbb3eef30dc557de8ec00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc58dbaf07bbb3eef30dc557de8ec00b">&#9670;&#160;</a></span>audioSettings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_audio_settings.html">IAudioSettings</a> IMachine::audioSettings</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The machine's audio settings. </p>

</div>
</div>
<a id="ac5638e205ed8f8a1473d3b866e9a7d4f" name="ac5638e205ed8f8a1473d3b866e9a7d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5638e205ed8f8a1473d3b866e9a7d4f">&#9670;&#160;</a></span>storageControllers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_storage_controller.html">IStorageController</a> [] IMachine::storageControllers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of storage controllers attached to this machine. </p>

</div>
</div>
<a id="a7e7b7939c050afa7475e249e06961e75" name="a7e7b7939c050afa7475e249e06961e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7b7939c050afa7475e249e06961e75">&#9670;&#160;</a></span>settingsFilePath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring IMachine::settingsFilePath</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full name of the file containing machine settings data. </p>

</div>
</div>
<a id="afce080a3b082fea41b9ba7f3b9c7c716" name="afce080a3b082fea41b9ba7f3b9c7c716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce080a3b082fea41b9ba7f3b9c7c716">&#9670;&#160;</a></span>settingsAuxFilePath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring IMachine::settingsAuxFilePath</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full name of the file containing auxiliary machine settings data. </p>

</div>
</div>
<a id="a7fa04613f860573400ba570fcf80f3ef" name="a7fa04613f860573400ba570fcf80f3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa04613f860573400ba570fcf80f3ef">&#9670;&#160;</a></span>settingsModified</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean IMachine::settingsModified</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the settings of this machine have been modified (but neither yet saved nor discarded). </p>
<dl class="section note"><dt>Note</dt><dd>Reading this property is only valid on instances returned by <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b> and on new machines created by <a class="el" href="interface_i_virtual_box.html#a1b70a47863291ef63443df0e49a30265">IVirtualBox::createMachine</a><b></b> or opened by <a class="el" href="interface_i_virtual_box.html#abed607b37d5c17bbd73e77b4778f409b">IVirtualBox::openMachine</a><b></b> but not yet registered, or on unregistered machines after calling <a class="el" href="interface_i_machine.html#a939a4b0bf949b0347c9e9d2acf320d1b">IMachine::unregister</a><b></b>. For all other cases, the settings can never be modified.</dd>
<dd>
For newly created unregistered machines, the value of this property is always <code>true</code> until <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> is called (no matter if any machine settings have been changed after the creation or not). For opened machines the value is set to <code>false</code> (and then follows to normal rules). </dd></dl>

</div>
</div>
<a id="aecc00e3c014d4548a025e4eafff7056e" name="aecc00e3c014d4548a025e4eafff7056e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc00e3c014d4548a025e4eafff7056e">&#9670;&#160;</a></span>sessionState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="_virtual_box_8idl.html#ac82c179a797c0d7c249d1b98a8e3aa8f">SessionState</a> IMachine::sessionState</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current session state for this machine. </p>

</div>
</div>
<a id="acc6b48e4903942bb0a356e5c081de870" name="acc6b48e4903942bb0a356e5c081de870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6b48e4903942bb0a356e5c081de870">&#9670;&#160;</a></span>sessionName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring IMachine::sessionName</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the session. </p>
<p>If <a class="el" href="interface_i_machine.html#aecc00e3c014d4548a025e4eafff7056e">sessionState</a><b></b> is Spawning or Locked, this attribute contains the same value as passed to the <a class="el" href="interface_i_machine.html#aa75e76da42ef908795d235d995262c6f">IMachine::launchVMProcess</a><b></b> method in the <em>name</em> parameter. If the session was established with <a class="el" href="interface_i_machine.html#af28da645b00a821547d9cb8e92f8b7b0">IMachine::lockMachine</a><b></b>, it is the name of the session (if set, otherwise empty string). If <a class="el" href="interface_i_machine.html#aecc00e3c014d4548a025e4eafff7056e">sessionState</a><b></b> is SessionClosed, the value of this attribute is an empty string. </p>

</div>
</div>
<a id="a7380f79a10f9813dbced54f51004c6b5" name="a7380f79a10f9813dbced54f51004c6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7380f79a10f9813dbced54f51004c6b5">&#9670;&#160;</a></span>sessionPID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long IMachine::sessionPID</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifier of the session process. </p>
<p>This attribute contains the platform-dependent identifier of the process whose session was used with <a class="el" href="interface_i_machine.html#af28da645b00a821547d9cb8e92f8b7b0">IMachine::lockMachine</a><b></b> call. The returned value is only valid if <a class="el" href="interface_i_machine.html#aecc00e3c014d4548a025e4eafff7056e">sessionState</a><b></b> is Locked or Unlocking by the time this property is read. </p>

</div>
</div>
<a id="a9653e9d996d60fc54e8bed22179d92b2" name="a9653e9d996d60fc54e8bed22179d92b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9653e9d996d60fc54e8bed22179d92b2">&#9670;&#160;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9eb">MachineState</a> IMachine::state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current execution state of this machine. </p>

</div>
</div>
<a id="a3a96e177095b0f13c2fc43f425d9a45d" name="a3a96e177095b0f13c2fc43f425d9a45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a96e177095b0f13c2fc43f425d9a45d">&#9670;&#160;</a></span>lastStateChange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute long long IMachine::lastStateChange</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timestamp of the last execution state change, in milliseconds since 1970-01-01 UTC. </p>

</div>
</div>
<a id="a6bf84094ff47ad0f8f2517ee513eed02" name="a6bf84094ff47ad0f8f2517ee513eed02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf84094ff47ad0f8f2517ee513eed02">&#9670;&#160;</a></span>stateFilePath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring IMachine::stateFilePath</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full path to the file that stores the execution state of the machine when it is in either the <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9ebac8fa7577db141baf9cc06279665f122b">MachineState_Saved</a><b></b> or <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9eba2e667c004d2a414418ebfbddb666e65b">MachineState_AbortedSaved</a><b></b> state. </p>
<dl class="section note"><dt>Note</dt><dd>When the machine is not in the Saved or AbortedSaved state, this attribute is an empty string. </dd></dl>

</div>
</div>
<a id="a27636df01fde10102799eec13416ab51" name="a27636df01fde10102799eec13416ab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27636df01fde10102799eec13416ab51">&#9670;&#160;</a></span>logFolder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring IMachine::logFolder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full path to the folder that stores a set of rotated log files recorded during machine execution. </p>
<p>The most recent log file is named <code>VBox.log</code>, the previous log file is named <code>VBox.log.1</code> and so on (up to <code>VBox.log.3</code> in the current version). </p>

</div>
</div>
<a id="ac785dbe04eccc0793d949d6940202767" name="ac785dbe04eccc0793d949d6940202767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac785dbe04eccc0793d949d6940202767">&#9670;&#160;</a></span>currentSnapshot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_snapshot.html">ISnapshot</a> IMachine::currentSnapshot</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current snapshot of this machine. </p>
<p>This is <code>null</code> if the machine currently has no snapshots. If it is not <code>null</code>, then it was set by one of <a class="el" href="interface_i_machine.html#ab39f2d35139941c3c2eb1afcc1b5a319">takeSnapshot</a><b></b>, <a class="el" href="interface_i_machine.html#a4d541f845c2744f78315d146cb86084c">deleteSnapshot</a><b></b> or <a class="el" href="interface_i_machine.html#a5b696740ceccb14750718e2648d6928c">restoreSnapshot</a><b></b>, depending on which was called last. See <a class="el" href="interface_i_snapshot.html">ISnapshot</a><b></b> for details. </p>

</div>
</div>
<a id="a1946d487a58f17cf4ee78a28c64a50da" name="a1946d487a58f17cf4ee78a28c64a50da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1946d487a58f17cf4ee78a28c64a50da">&#9670;&#160;</a></span>snapshotCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long IMachine::snapshotCount</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of snapshots taken on this machine. </p>
<p>Zero means the machine doesn't have any snapshots. </p>

</div>
</div>
<a id="a141d87506c33bd09d7fad144ca52c871" name="a141d87506c33bd09d7fad144ca52c871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141d87506c33bd09d7fad144ca52c871">&#9670;&#160;</a></span>currentStateModified</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean IMachine::currentStateModified</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the current state of the machine is not identical to the state stored in the current snapshot. </p>
<p>The current state is identical to the current snapshot only directly after one of the following calls are made:</p>
<ul>
<li>
<a class="el" href="interface_i_machine.html#a5b696740ceccb14750718e2648d6928c">restoreSnapshot</a><b></b></li>
<li>
<a class="el" href="interface_i_machine.html#ab39f2d35139941c3c2eb1afcc1b5a319">takeSnapshot</a><b></b> (issued on a "powered off" or "saved" machine, for which <a class="el" href="interface_i_machine.html#a7fa04613f860573400ba570fcf80f3ef">settingsModified</a><b></b> returns <code>false</code>) </li>
</ul>
<p>The current state remains identical until one of the following happens:</p>
<ul>
<li>
settings of the machine are changed</li>
<li>
the saved state is deleted</li>
<li>
the current snapshot is deleted</li>
<li>
an attempt to execute the machine is made</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For machines that don't have snapshots, this property is always <code>false</code>. </dd></dl>

</div>
</div>
<a id="ab9d48e83d2a8b245afa00116b1e7ca37" name="ab9d48e83d2a8b245afa00116b1e7ca37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d48e83d2a8b245afa00116b1e7ca37">&#9670;&#160;</a></span>sharedFolders</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_shared_folder.html">ISharedFolder</a> [] IMachine::sharedFolders</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collection of shared folders for this machine (permanent shared folders). </p>
<p>These folders are shared automatically at machine startup and available only to the guest OS installed within this machine.</p>
<p>New shared folders are added to the collection using <a class="el" href="interface_i_machine.html#a56d8797225812968b96f0663a02bd4ff">createSharedFolder</a><b></b>. Existing shared folders can be removed using <a class="el" href="interface_i_machine.html#a30e6a10490fde39a3e97e2ae1d1fa3ce">removeSharedFolder</a><b></b>. </p>

</div>
</div>
<a id="ab21aa593375c45dcd5a7b4c3a2a73b5f" name="ab21aa593375c45dcd5a7b4c3a2a73b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21aa593375c45dcd5a7b4c3a2a73b5f">&#9670;&#160;</a></span>clipboardMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#a096d8cfa9dea55360b7d50c70176a222">ClipboardMode</a> IMachine::clipboardMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronization mode between the host OS clipboard and the guest OS clipboard. </p>

</div>
</div>
<a id="a12ee7d598e66bb5ab87f496c3ea66d72" name="a12ee7d598e66bb5ab87f496c3ea66d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ee7d598e66bb5ab87f496c3ea66d72">&#9670;&#160;</a></span>clipboardFileTransfersEnabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean IMachine::clipboardFileTransfersEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or retrieves whether clipboard file transfers are allowed or not. </p>
<p>When set to <em>true</em>, clipboard file transfers between supported host and guest OSes are allowed. </p>

</div>
</div>
<a id="a161a779fa01e1ff5e50982205a32e805" name="a161a779fa01e1ff5e50982205a32e805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161a779fa01e1ff5e50982205a32e805">&#9670;&#160;</a></span>dnDMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#a6e9dd4a91e0d1048c9373e6eeb93aa4a">DnDMode</a> IMachine::dnDMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or retrieves the current drag'n drop mode. </p>

</div>
</div>
<a id="a662d92a1c47ac75f15a4660ae5247d22" name="a662d92a1c47ac75f15a4660ae5247d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662d92a1c47ac75f15a4660ae5247d22">&#9670;&#160;</a></span>teleporterEnabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean IMachine::teleporterEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When set to <em>true</em>, the virtual machine becomes a target teleporter the next time it is powered on. </p>
<p>This can only set to <em>true</em> when the VM is in the <em>PoweredOff</em> or <em>Aborted</em> state. </p>

</div>
</div>
<a id="a45fb6bfa8fc01e46728d3c7ee716a237" name="a45fb6bfa8fc01e46728d3c7ee716a237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fb6bfa8fc01e46728d3c7ee716a237">&#9670;&#160;</a></span>teleporterPort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long IMachine::teleporterPort</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The TCP port the target teleporter will listen for incoming teleportations on. </p>
<p>0 means the port is automatically selected upon power on. The actual value can be read from this property while the machine is waiting for incoming teleportations. </p>

</div>
</div>
<a id="a0f8a33069ddcde81ba6928f11584cb3b" name="a0f8a33069ddcde81ba6928f11584cb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8a33069ddcde81ba6928f11584cb3b">&#9670;&#160;</a></span>teleporterAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::teleporterAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The address the target teleporter will listen on. </p>
<p>If set to an empty string, it will listen on all addresses. </p>

</div>
</div>
<a id="a7df9bcd55c58f6565e20833e50643e79" name="a7df9bcd55c58f6565e20833e50643e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df9bcd55c58f6565e20833e50643e79">&#9670;&#160;</a></span>teleporterPassword</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::teleporterPassword</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The password to check for on the target teleporter. </p>
<p>This is just a very basic measure to prevent simple hacks and operators accidentally beaming a virtual machine to the wrong place.</p>
<p>Note that you SET a plain text password while reading back a HASHED password. Setting a hashed password is currently not supported. </p>

</div>
</div>
<a id="a97cc37de9ba8da175b44e7c03baa34bd" name="a97cc37de9ba8da175b44e7c03baa34bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cc37de9ba8da175b44e7c03baa34bd">&#9670;&#160;</a></span>paravirtProvider</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#ad4d63f64a610fd190118618ceac0f6ee">ParavirtProvider</a> IMachine::paravirtProvider</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The paravirtualized guest interface provider. </p>

</div>
</div>
<a id="a9999c5c9eb8eecac98a45bde62fc3bce" name="a9999c5c9eb8eecac98a45bde62fc3bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9999c5c9eb8eecac98a45bde62fc3bce">&#9670;&#160;</a></span>IOCacheEnabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean IMachine::IOCacheEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When set to <em>true</em>, the builtin I/O cache of the virtual machine will be enabled. </p>

</div>
</div>
<a id="a596ae3cdd7eea9f92c79dddd4c738f6f" name="a596ae3cdd7eea9f92c79dddd4c738f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596ae3cdd7eea9f92c79dddd4c738f6f">&#9670;&#160;</a></span>IOCacheSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long IMachine::IOCacheSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of the I/O cache in MB. </p>

</div>
</div>
<a id="a38a5c9476de084724b89fda4ea26ae12" name="a38a5c9476de084724b89fda4ea26ae12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a5c9476de084724b89fda4ea26ae12">&#9670;&#160;</a></span>PCIDeviceAssignments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_p_c_i_device_attachment.html">IPCIDeviceAttachment</a> [] IMachine::PCIDeviceAssignments</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of PCI devices assigned to this machine, to get list of all PCI devices attached to the machine use <a class="el" href="interface_i_console.html#a6d41c200e67a37cdbc9c270317831774">IConsole::attachedPCIDevices</a><b></b> attribute, as this attribute is intended to list only devices additional to what described in virtual hardware config. </p>
<p>Usually, this list keeps host's physical devices assigned to the particular machine. </p>

</div>
</div>
<a id="a15c8725d2d0bf1bc99d3fc2048dfe98a" name="a15c8725d2d0bf1bc99d3fc2048dfe98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c8725d2d0bf1bc99d3fc2048dfe98a">&#9670;&#160;</a></span>bandwidthControl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_bandwidth_control.html">IBandwidthControl</a> IMachine::bandwidthControl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bandwidth control manager. </p>

</div>
</div>
<a id="a08618a97a181c10f9113b3844d6ae577" name="a08618a97a181c10f9113b3844d6ae577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08618a97a181c10f9113b3844d6ae577">&#9670;&#160;</a></span>tracingEnabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean IMachine::tracingEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the tracing facility in the VMM (including PDM devices + drivers). </p>
<p>The VMM will consume about 0.5MB of more memory when enabled and there may be some extra overhead from tracepoints that are always enabled. </p>

</div>
</div>
<a id="a2f4ec9af3f5705deed580ccba5a2e142" name="a2f4ec9af3f5705deed580ccba5a2e142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4ec9af3f5705deed580ccba5a2e142">&#9670;&#160;</a></span>tracingConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::tracingConfig</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracepoint configuration to apply at startup when <a class="el" href="interface_i_machine.html#a08618a97a181c10f9113b3844d6ae577">IMachine::tracingEnabled</a><b></b> is true. </p>
<p>The string specifies a space separated of tracepoint group names to enable. The special group 'all' enables all tracepoints. Check DBGFR3TracingConfig for more details on available tracepoint groups and such.</p>
<p>Note that on hosts supporting DTrace (or similar), a lot of the tracepoints may be implemented exclusively as DTrace probes. So, the effect of the same config may differ between Solaris and Windows for example. </p>

</div>
</div>
<a id="acfa33f6952f420c0163dd2eefccc62ed" name="acfa33f6952f420c0163dd2eefccc62ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa33f6952f420c0163dd2eefccc62ed">&#9670;&#160;</a></span>allowTracingToAccessVM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean IMachine::allowTracingToAccessVM</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables tracepoints in PDM devices and drivers to use the VMCPU or VM structures when firing off trace points. </p>
<p>This is especially useful with DTrace tracepoints, as it allows you to use the VMCPU or VM pointer to obtain useful information such as guest register state.</p>
<p>This is disabled by default because devices and drivers normally has no business accessing the VMCPU or VM structures, and are therefore unable to get any pointers to these. </p>

</div>
</div>
<a id="aca5154cad0ba95af8d3ce358571222bc" name="aca5154cad0ba95af8d3ce358571222bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5154cad0ba95af8d3ce358571222bc">&#9670;&#160;</a></span>autostartEnabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean IMachine::autostartEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables autostart of the VM during system boot. </p>

</div>
</div>
<a id="a9d371d975c607f0d3f81ab57459149df" name="a9d371d975c607f0d3f81ab57459149df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d371d975c607f0d3f81ab57459149df">&#9670;&#160;</a></span>autostartDelay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long IMachine::autostartDelay</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of seconds to wait until the VM should be started during system boot. </p>

</div>
</div>
<a id="a724adf774f12d25744bbac488c7fe26e" name="a724adf774f12d25744bbac488c7fe26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724adf774f12d25744bbac488c7fe26e">&#9670;&#160;</a></span>autostopType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#a03ad7f2af3ceb813a15cdc614db93c73">AutostopType</a> IMachine::autostopType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Action type to do when the system is shutting down. </p>

</div>
</div>
<a id="a219a6cc56c7488c1873418e49dfd2c69" name="a219a6cc56c7488c1873418e49dfd2c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219a6cc56c7488c1873418e49dfd2c69">&#9670;&#160;</a></span>defaultFrontend</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::defaultFrontend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects which VM frontend should be used by default when launching this VM through the <a class="el" href="interface_i_machine.html#aa75e76da42ef908795d235d995262c6f">IMachine::launchVMProcess</a><b></b> method. </p>
<p>Empty or <code>null</code> strings do not define a particular default, it is up to <a class="el" href="interface_i_machine.html#aa75e76da42ef908795d235d995262c6f">IMachine::launchVMProcess</a><b></b> to select one. See the description of <a class="el" href="interface_i_machine.html#aa75e76da42ef908795d235d995262c6f">IMachine::launchVMProcess</a><b></b> for the valid frontend types.</p>
<p>This per-VM setting overrides the default defined by <a class="el" href="interface_i_system_properties.html#aa78a4624ed0d220db7a47a038b818194">ISystemProperties::defaultFrontend</a><b></b> attribute, and is overridden by a frontend type passed to <a class="el" href="interface_i_machine.html#aa75e76da42ef908795d235d995262c6f">IMachine::launchVMProcess</a><b></b>. </p>

</div>
</div>
<a id="af07caab27f0c5c1eca2e513dc2f29be7" name="af07caab27f0c5c1eca2e513dc2f29be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07caab27f0c5c1eca2e513dc2f29be7">&#9670;&#160;</a></span>USBProxyAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean IMachine::USBProxyAvailable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there is a USB proxy available. </p>

</div>
</div>
<a id="ac3d9918ca129ee856a9e17004a3c6daa" name="ac3d9918ca129ee856a9e17004a3c6daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d9918ca129ee856a9e17004a3c6daa">&#9670;&#160;</a></span>VMProcessPriority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#acc3c8270a58faac4d5121d99a8549c49">VMProcPriority</a> IMachine::VMProcessPriority</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the priority of the VM process. </p>
<p>It is a VM setting which can be changed both before starting the VM and at runtime.</p>
<p>The default value is 'Default', which selects the default process priority.</p>
<dl class="section user"><dt>Expected result codes:</dt><dd><table class="doxtable">
<tr>
<td>E_NOTIMPL</td><td>This attribute is currently not implemented. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a87d572badb3f0a926770566b3d1795e7" name="a87d572badb3f0a926770566b3d1795e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d572badb3f0a926770566b3d1795e7">&#9670;&#160;</a></span>VMExecutionEngine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#aa6b799bf0e81e1dcaeb02803c36f510f">VMExecutionEngine</a> IMachine::VMExecutionEngine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The configured VM execution engine. </p>
<p>It is a VM setting which can be changed both before starting the VM and when a VM is saved.</p>
<p>The default value is 'Default', which selects the default aka best available execution engine available on the host. </p>

</div>
</div>
<a id="a15ef62440037c084157ace16494cc563" name="a15ef62440037c084157ace16494cc563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ef62440037c084157ace16494cc563">&#9670;&#160;</a></span>paravirtDebug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::paravirtDebug</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug parameters for the paravirtualized guest interface provider. </p>

</div>
</div>
<a id="ae0c497fcc86cb5a515646287080feea9" name="ae0c497fcc86cb5a515646287080feea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c497fcc86cb5a515646287080feea9">&#9670;&#160;</a></span>CPUProfile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring IMachine::CPUProfile</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Experimental feature to select the guest CPU profile. </p>
<p>The default is "host", which indicates the host CPU. All other names are subject to change.</p>
<p>Use the <a class="el" href="interface_i_system_properties.html#a8772aac880c9a3e1d5724c316bc5d2e4">ISystemProperties::getCPUProfiles</a><b></b> method to get currently available CPU profiles. </p>

</div>
</div>
<a id="a38718ba046f8462f325647afd52f7cd3" name="a38718ba046f8462f325647afd52f7cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38718ba046f8462f325647afd52f7cd3">&#9670;&#160;</a></span>stateKeyId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring IMachine::stateKeyId</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key Id of the password used for encrypting the state file. </p>
<p>Internal use only for now. </p>

</div>
</div>
<a id="a7a6eb3f6087a43cd1721ee7a659d8a6a" name="a7a6eb3f6087a43cd1721ee7a659d8a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6eb3f6087a43cd1721ee7a659d8a6a">&#9670;&#160;</a></span>stateKeyStore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring IMachine::stateKeyStore</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key store used for encrypting the state file. </p>
<p>Internal use only for now. </p>

</div>
</div>
<a id="a2bee1a4d7d9b271b77f063757f426e9a" name="a2bee1a4d7d9b271b77f063757f426e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bee1a4d7d9b271b77f063757f426e9a">&#9670;&#160;</a></span>logKeyId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring IMachine::logKeyId</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key Id of the password used for encrypting the log files. </p>
<p>Internal use only for now. </p>

</div>
</div>
<a id="a08c13e46eb7de7852226047dc5aeca66" name="a08c13e46eb7de7852226047dc5aeca66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c13e46eb7de7852226047dc5aeca66">&#9670;&#160;</a></span>logKeyStore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring IMachine::logKeyStore</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key store used for encrypting the log files. </p>
<p>Internal use only for now. </p>

</div>
</div>
<a id="a76ccc2041a103f76e978fce989e911b5" name="a76ccc2041a103f76e978fce989e911b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ccc2041a103f76e978fce989e911b5">&#9670;&#160;</a></span>guestDebugControl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_guest_debug_control.html">IGuestDebugControl</a> IMachine::guestDebugControl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Guest debugging configuration. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
